---
title: "나는코더다 2019 송년대회 이야기"
date: 2020-02-15 17:03:27
categories:
 - Contest
 - Review
tags:
 - 대회
 - 풀이
 - 출제
 - 나는코더다
---

## 머릿말

2019년 12월 12일과 14일에 진행되었던 나는코더다 2019 송년대회([교내](https://www.acmicpc.net/contest/view/493) / [Open](https://www.acmicpc.net/contest/view/494))에 관하여, 이제나마 글을 적는다.

그 당시 나는 대회가 끝나자마자 이 글을 올리고 싶었는데, 개인 블로그가 없었는지라... 많이 늦었지만, 최대한 기억을 되살려서 글을 몇 자 적어본다.

2019년이 되자마자 나는 '나는코더다 기장으로서 대회를 열어야 한다'는 생각을 가지고 있었다. 연초부터 세빈이를 나와 함께 할 출제위원 자리로 앉혀놓고, 대회 문제를 준비하였다. 거의 1년 가까이 문제 아이디어를 모아두었기 때문에, 출제에 있어서 큰 어려움은 없었던 것 같다.

대회 문제는 나와 세빈이가 전부 만들었지만, 대회를 운영함에 있어 그 나머지 부분은 여섯 분의 훌륭한 외부검수진이 빈틈없이 채워주셨다. (사전순으로) [cubelover](https://www.acmicpc.net/user/cubelover), [imeimi2000](https://www.acmicpc.net/user/imeimi2000), [jwvg0425](https://www.acmicpc.net/user/jwvg0425), [koosaga](https://www.acmicpc.net/user/koosaga), [rkm0959](https://www.acmicpc.net/user/rkm0959), [TAMREF](https://www.acmicpc.net/user/TAMREF). 모두 귀중한 시간을 내주시며, 문제의 퀄리티를 크게 높여주심과 동시에, 대회 전반에 있어 값진 피드백을 아낌없이 주셨다. 이 분들에게 다시 한 번 감사의 말씀을 드린다.

또한, 송년대회가 더욱 즐거운 대회가 될 수 있도록 상품과 간식 등을 아낌없이 지원해주신 [NEXON](https://www.nexon.com/)과 관계자 분들께도 깊은 감사의 말씀을 드린다.



## 대회 개요

|       문제 이름       | 출제자 |                      First Solve (교내)                      | First Solve (Open) |
| :-------------------: | :----: | :----------------------------------------------------------: | :----------------: |
|       평면 분할       | 윤교준 |               지학 전공 (김수민, 신재훈) - 4분               |        N/A         |
|       라면 사기       | 윤교준 |         킹장배빵빵 (황인성, 김도영B, 이도훈) - 80분          |  august14 - 11분   |
|       분할하기        | 윤교준 | 대가리 큰 곰돌이 푸를 사냥하는 명 윅은 노래를 부르다가 특별상만을 노린다. (성재용, 신명진, 조강현) - 26분 |    ainta - 15분    |
|     다오의 데이트     | 윤교준 |                     1111 (박준호) - 38분                     |   povwhm - 27분    |
|    참 어려운 문제     | 윤교준 |           HLD조아 (정희승, 임성재, 최승민) - 192분           |  cki86201 - 29분   |
|     촛불과 그림자     | 윤교준 |                           No Solve                           |      No Solve      |
|      피아노 연주      | 김세빈 |         뚝심햄구이 (이종영, 안지민, 최은수) - 214분          |   tlwpdus - 22분   |
|       보고 정렬       | 김세빈 |           🇰🇷815🇰🇷 (고동현, 이민제, 이강민) - 19분            |   kcm1700 - 29분   |
|   비행기 타고 가요    | 윤교준 |          뚝심햄구이 (이종영, 안지민, 최은수) - 23분          |    ainta - 78분    |
| Bad Hair Day와 기댓값 | 김세빈 |         뚝심햄구이 (이종영, 안지민, 최은수) - 136분          |   ainta - 159분    |
|       정점 찾기       | 윤교준 |           🇰🇷815🇰🇷 (고동현, 이민제, 이강민) - 185분           |  august14 - 99분   |
|       정기 모임       | 김세빈 |         뚝심햄구이 (이종영, 안지민, 최은수) - 195분          |  onjo0127 - 158분  |
|       분수 계산       | 윤교준 |     의문부호의 꼭두각시 (김석표, 이민규, 이민준) - 172분     |    ainta - 90분    |

"평면 분할" 문제는 교내 대회에만 출제되었다. 놀랍게도 교내와 Open 모두에서 "촛불과 그림자"를 제외한 모든 문제가 풀렸다.

여담이지만, "촛불과 그림자"를 제외한 모든 문제의 출제자 정해 코드는 아주 짧다. ("촛불과 그림자" 제외) 평균 C++ 코드 길이는 700 bytes밖에 되지 않는다. 대회 문제의 퀄리티와 풀이의 깔끔함을 강조하고 싶다.

세빈이가 모든 문제의 풀이를 아주 깔끔하게 정리해주었다. <a href="/downloadable_files/iamcoder_2019_yearend_solution.pdf" download>[세빈이의 풀이 슬라이드]</a>



## 대회 문제

### [평면 분할](https://www.acmicpc.net/problem/18187)

#### 개요

출제자 : 윤교준 / 데이터 제작자 : 윤교준<br>운영진의 최단 코드 : 200 bytes (C++), 49 bytes (Python)<br>교내 First Solver : 지학 전공 (김수민, 신재훈) - 4분

> 이차원 평면에 기울기가 $-1$, $0$, $1$인 직선을 최대 $N$개 그릴 수 있다.<br>직선에 의해 분할되는 영역의 개수의 최댓값을 구하시오.

모든 참가자가 풀 수 있는 문제를 하나는 내야겠다고 생각해서 만들었다. 난도가 아주 낮기 때문에 Open에는 출제하지 않았다.

교내의 잘하는 팀은 문제를 읽자마자 바로 풀지 않을까 생각했지만, 실제로는 First Solve가 의외의 팀이 대회 시작 후 4분에 푼 것이라 당황스러웠다.

정답률은 84%로 최대고, 참가한 모든 팀이 풀어서 '맞았습니다'를 받았다. 다만, $\frac{N(N+1)}{2} + 1$를 출력하는 오답 코드가 많아서 아쉽다.

#### 풀이

한 점에서 만나는 세 직선이 있다면 이들 중 하나를 살짝 평행이동함으로써, 세 직선이 한 점에서 만나지 않도록 함과 동시에 답을 더 크게 만들 수 있다. 고로, 해의 어느 세 직선도 한 점에서 만나지 않는다.

기울기가 $-1$, $0$, $1$인 직선을 각각 $a$, $b$, $c$개 그린다고 하자. 그러면 분할되는 영역의 수는 $(a+1)(b+1)(c+1) - abc$다.

$a+b+c \le N$를 만족하는 모든 $(a, b, c)$ 쌍에 대하여 영역의 수를 구해, 그 최댓값을 출력하면 된다.

더 고민해보면, 답은 항상 $\left\lfloor{\frac{N^2}{3}}\right\rfloor + N + 1$임을 알 수 있다.



### 라면 사기 ([Small](https://www.acmicpc.net/problem/18185) / [Large](https://www.acmicpc.net/problem/18186))

#### 개요

출제자 : 윤교준 / 데이터 제작자 : TAMREF, 윤교준<br>운영진의 최단 코드 : [Small] 479 bytes (C++) / [Large] 496 bytes (C++)<br>교내 First Solver : 킹장배빵빵 (황인성, 김도영B, 이도훈) - 80분<br>Open First Solver : august14 - 11분

> $N$개의 라면 공장이 있다. 각 공장에서 정해진 수량의 라면을 사고자 한다.<br>연속한 1개, 2개, 3개의 공장에서 라면을 하나씩 구매하는 비용이 각각 $B$, $B+C$, $B+2C$다.<br>최소 비용으로 구매할 때, 그 금액을 구하시오.

IZhO 2011의 [Skyline 문제](https://www.acmicpc.net/problem/11835)에서 제한을 크게 한 문제다. 교내 대회에는 $N \le 10^4$, $A_i \le 10^4$, $B = 3$, $C = 2$라는 추가적인 조건을 넣어서 Small 버전으로 출제하였다. 그렇기에 Small 버전으로 문제를 접한 교내 팀은 옳바른 풀이를 찾는 것이 Large 버전보다 더 어려웠을 것이라 생각한다. 동적계획법 풀이는 시간복잡도가 $O(N^3)$로 느리고, 그렇다고 $O(N^2)$ 혹은 $O(NX)$에 동작하는 올바른 풀이는 찾기 어렵기 때문이다.

정해는 놀랍게도 선형에 풀린다. 모두가 Greedy 문제임을 알지만, 올바르게 접근하기 어려움은 사실이다. 교내와 Open 모두에서 정답률이 17%임이 이를 말해준다. Scoreboard가 비공개였다면 모두가 한 번씩은 제출하고 틀리지 않았을까 생각한다.

개인적으로 내가 만든 가장 아름다운 문제라고 생각한다. 짧은 Description, 깔끔한 소스코드, 그러나 어려운 Greedy 풀이. 덤으로, Open에서 4위를 한 ainta가 이 문제를 풀었다면 3위를 차지하여 상품을 얻을 수 있었다. 어떻게 보면 이 문제가 상품 수상권을 갈랐다고도 말할 수 있을 것이다.

#### 풀이

만약 $B < C$라면, $C := B$라고 가정해도 답이 변하지 않는다. 이제, $C \le B$가 성립한다.

$1$번 공장부터 $i$번 공장까지 최소 비용으로 라면을 구매하는 해를 이용하여, $i+1$번 공장까지 구매하는 최적해를 구하는 방법을 서술할 것이다.<br>아래의 세 과정을 순서대로 시행하되, 각각의 과정을 최대한 많이 시행한다:

1. "$i$번 공장에서 비용 $B$로 라면 구매"를 "$i$번과 $i+1$번 공장에서 비용 $B+C$로 라면 구매"로 변경.
2. "$i-1$번과 $i$번 공장에서 비용 $B+C$로 라면 구매"를 "$i-1$번, $i$번, $i+1$번 공장에서 비용 $B+2C$로 라면 구매"로 변경.
3. $i+1$번 공장에서 비용 $B$로 라면 구매.

정당성 증명은 꽤 단순하다. 각 라면마다 B, C, D 중 하나의 알파벳을 적는다고 하자. 각 알파벳의 의미를 설명하자면:

- "B를 적는 것"은 "그 라면을 비용 $B$로 구매함"을
- "C를 적는 것"은 "이전의 B가 적힌 라면과 엮어, 라면을 비용 $C$로 구매함"을
- "D를 적는 것"은 "두 공장 전의 B가 적힌 라면과, 이전의 C가 적힌 라면과 엮어, 라면을 비용 $C$로 구매함"을 의미한다.

총 구매 비용은 $B \times (\text{B가 적힌 라면의 개수}) + C \times (\text{C나 D가 적힌 라면의 개수})$이므로, B를 최대한 적게 적는 것이 목표다.

이제 위에서 서술한 과정의 의미를 파악해보자. 각 과정의 의미는 다음과 같다:

1. $i$번 공장의 "B가 적힌 라면"을 최대한 많이 이용하여, $i+1$번 공장의 라면에 C를 적는다.
2. $i$번 공장의 "C가 적힌 라면"을 최대한 많이 이용하여, $i+1$번 공장의 라면에 D를 적는다.
3. 남은 $i+1$번 공장의 라면에 B를 적는다.

만일, 위와 같은 과정으로 만들어지지 않은 해가 있다면, 그 해에서 B를 C로 고치거나, C를 D로 고치는 작업을 항상 한 번 이상 할 수 있다. 따라서, 제시한 Greedy 풀이는 정당하다.



### [분할하기](https://www.acmicpc.net/problem/18184)

#### 개요

출제자 : 윤교준 / 데이터 제작자 : 윤교준<br>운영진의 최단 코드 : 239 bytes (C++)<br>교내 First Solver : 대가리 큰 곰돌이 푸를 사냥하는 명 윅은 노래를 부르다가 특별상만을 노린다. (성재용, 신명진, 조강현) - 26분<br>Open First Solver : ainta - 15분

> 어떤 집합이 Bitwise-or 연산에 대하여 닫혀있다면, 그 집합을 "좋은 집합"이라고 하자.<br>전체집합 $U = \{ 0, 1, \cdots, 2^N - 1 \}$의 부분집합 $A$에 대하여, $\left\|A\right\| = K$고, $A$와 $U \setminus A$가 모두 좋은 집합이면, $A$를 "$N, K$-분할"이라고 하자.<br>$N$과 $K$가 주어질 때, "$N, K$-분할"의 존재성을 밝히고, 만일 존재한다면 그 예를 아무거나 하나 출력하시오.

아이디어가 있어야 풀 수 있는 문제를 만들어보았다. 이 문제를 푸는데, 출제한 나는 며칠이 걸렸고, 검수진 몇몇은 반나절 이상 걸리길래, 나는 문제의 난도가 높다고 생각했다. 교내 대회에서 18팀 중 절반 이상이 못 풀지 않을까 예상했는데, 실제로는 26분만에 First Solve가 나오고, 총 18팀 중 13팀이나 풀어서 굉장히 놀라웠다.

다양한 풀이가 있을 것이라고 생각하고 출제를 했는데, 대부분의 참가자 풀이가 의도된 풀이와 유사하였다. Special Judge는 Or-convolution을 이용하여 $O(2^N N)$에 구현할 수 있으나, ~~내가 귀찮아서~~ 구현의 정확도가 우선이라고 생각해서 $O(2^{2N})$로 naive하게 구현하였다.

#### 풀이

$N,K$-분할은 항상 존재하며, 이러한 집합을 만드는 방법은 단순하다.

다음 $N+1$개의 집합을 생각하자:

$$ \{ 0 \}, \{ 1 \}, \{ 2, 3 \}, \{ 4, 5, 6, 7 \}, \cdots, \{ 2^i, 2^i + 1, \cdots, 2^{i+1} - 1\}, \cdots, \{ 2^{N-1}, 2^{N-1}+1, \cdots, 2^N - 1 \} $$

이제 우리는 다음 두 가지 성질을 관찰할 수 있다:

- 각 집합의 크기는 $1, 1, 2, 4, \cdots, 2^i, \cdots, 2^{N-1}$다.
- $N+1$개의 집합 중 몇 개를 골랐을 때, 이들의 합집합과 그의 여집합은 항상 좋은 집합이다.

고로, 우리는 모든 $N,K$-분할을 만들 수 있다. $1 \le K < 2^N$라면, 최상위 비트가 $K$에 포함된 수의 집합이 곧 $N,K$-분할이 된다.



### [다오의 데이트](https://www.acmicpc.net/problem/18188)

#### 개요

출제자 : 윤교준 / 데이터 제작자 : 윤교준<br>운영진의 최단 코드 : 870 bytes (C++)<br>교내 First Solver : 1111 (박준호) - 38분<br>Open First Solver : povwhm - 27분

> 이차원 격자판 위에 다오와 디지니가 서 있다.<br>다오는 최대 $N$번 움직일 수 있으며, 각 움직임마다 두 방향 중 한 쪽으로만 이동할 수 있다.<br>다오와 디지니가 만날 수 있는지 판별하고, 만일 가능하다면 그 방법을 구하시오.

올해 나는코더다 송년대회는 처음으로 외부 기업으로부터 후원을 받았다. NEXON 사회공헌팀에 직접 후원 관련 연락을 드렸고, NEXON 분들께서 흔쾌히 허락해주셔서 정말 기뻤다. 출제·검수 비용과 교내 대회장에 비치할 다과·음료 구매비, 참가자 간식 비용, 우승 상품 등을 모두 지원해주셨다. 학생 대회에 굉장히 큰 후원을 해주셨음에도 불구하고, NEXON은 그 어떤 후원 조건도 제시하지 않으셔서, 감사함을 표현하고자 이 문제를 만들었다.

문제 컨셉은 크레이지 파크에서 가져왔다. 문제를 제작하면서 크레이지 파크를 찾아봤는데 어느새인가 서비스를 종료했더라.... 좌우지간, 후원기업 NEXON에 내가 바치는 문제였기에, 문제 구성과 난이도, 데이터 모두에 신경을 아주 많이 썼다.

쓰다보니 생각이 났는데, 문제의 아이디어는 정종광 선생님께서 제공해주셨다. 출제에 도움을 주신 것에 대하여 정종광 선생님께 고마운 마음을 전해드리고 싶다.

#### 풀이

다오가 움직일 수 있는 방법은 총 $O(2^N)$가지다. $N \le 20$으로 굉장히 작기 때문에, 모든 경우를 전부 시도해도 괜찮다.

의외로, 정답률은 교내 22%, Open 40%로 낮은데, 이는 내가 문제 설명을 깔끔하게 쓰지 못했기 때문이라고 생각한다.



### [참 어려운 문제](https://www.acmicpc.net/problem/18189)

#### 개요

출제자 : 윤교준 / 데이터 제작자 : 김세빈<br>운영진의 최단 코드 : 816 bytes (C++)<br>교내 First Solver : HLD조아 (정희승, 임성재, 최승민) - 192분<br>Open First Solver : cki86201 - 29분

> 각 정점에 색이 칠해져 있는 트리가 주어진다.<br>조상-자식 관계이면서 색이 같은 두 정점이 존재하지 않도록 트리의 루트를 잡을 때, 루트로 가능한 정점을 모두 구하시오.

그냥 갑자기 이런 문제가 떠올라서, 풀리는지 제대로 확인도 안 하고 대회 문제 Shortlist에 던져놓았다. 나는 '열심히 코딩하면 $O(N lgN)$ 즈음에 풀리겠지'까지만 생각했는데, 세빈이와 imeimi2000가 뭔가 뚝딱뚝딱 하더니 갓 풀이를 만들어 놓아서 정말정말 신기했다.

데이터를 만들기 아주 어려운 문제라고 생각한다. $O(N^2)$ 시간 커팅 야매라던가, 코딩 미스라던가, 랜덤을 섞다던가.... 통과시키면 안되는 풀이가 아주 많고, 트리와 색을 구성하는 것이 아주 까다로움에도 불구하고, 데이터는 아주 완벽하다고 생각한다. 열심히 준비하느라 고생한 세빈이에게 아낌없이 박수를 쳐주자.

#### 풀이 1

이 문제는 교내에서 두 팀, Open에서 네 명이 풀었고, 전부 본 풀이와 비슷한 방법으로 해결하였다.

트리 중 간선 $\{ u, v \}$을 생각하자. 이 간선을 끊는다면, 트리는 두 개의 트리 $T_u$와 $T_v$로 분리된다. 여기서, $T_u$는 정점 $u$가 포함된 트리, $T_v$는 정점 $v$가 포함된 트리다.

만일, $u$와 색이 같은 $T_v$ 상의 정점이 존재한다면, $T_u$의 모든 정점은 답의 후보에서 제외된다. 이렇게 모든 $N-1$개의 간선에 대하여, 답의 후보를 제거하자. 남은 후보 정점은 모두 루트가 될 수 있음을 보일 수 있다.

따라서, 우리가 구현해야 하는 부분은 크게 두 가지로 볼 수 있다:

- $T_v$의 정점 중 $u$와 색이 같은 정점이 존재하는지 판별 : DFS Ordering과 같은 색을 가진 정점의 index를 모아두는 $O(N)$ 전처리로, 각 쿼리마다 이분탐색 등으로 $O(lg N)$에 판별할 수 있다.
- 답의 최종 후보 정점 결정 : 각 간선에 대하여, $O(1)$에 답이 될 수 없는 부트리의 루트에만 정보를 저장한 후, $O(N)$의 DFS를 통하여, 최종 후보를 알아낼 수 있다.

시간복잡도는 $O(N lgN)$, 공간 복잡도는 $O(N)$다. 구현 방식에 따라 코딩량이 크게 다른 듯 하다.

#### 풀이 2

이 풀이는 내가 생각한 방법이다. 아무 생각 없이 손만 열심히 움직이는 풀이다.

색이 $C$로 같은 정점을 모두 모아, 트리 압축을 해보자. 이제 두 가지 경우가 있다:

- 색이 $C$인 정점 중 Leaf가 아닌 정점이 존재하는 경우 : 모든 정점이 답이 될 수 없다.
- 색이 $C$인 정점이 모두 Leaf인 경우 : 압축된 트리 중 색이 $C$가 아닌 모든 정점이 답의 후보가 될 수 있다.

모든 색에 대하여, 위의 과정을 진행한 후, 모든 답의 후보의 교집합을 구하면 그것이 답이 된다.

트리 압축 테크닉을 언급해보고 싶어서, 본 풀이를 적었다. 시간복잡도와 공간 복잡도 모두 $O(N lgN)$다.

#### 풀이 3

세빈이의 풀이 슬라이드를 보면, "DFS를 돌면서 각 색깔별로 따로 스택을 관리하여 선형에 풀 수 있다."고 적혀 있는데, 나는 이 의미를 모르겠다. 선형 풀이도 $O(N lgN)$ 풀이처럼 다양한 듯 하나, 여기서 나는 imeimi2000의 갓 풀이만 설명할 것이다.

다음을 차례대로 관찰하자:

1. 유일한 색을 가지는 정점의 집합을 $S$라 하자. 답은 $S$의 부분집합이다.
2. **풀이 2**에 의해, 답이 되는 정점은 여러 부트리의 교집합의 형태를 가진다. 고로, 답이 되는 정점은 모두 이어져있다.
3. 인접한 두 정점 $u, v \in S$을 생각하자. $u$가 루트가 될 수 있다면, $v$ 또한 루트가 될 수 있다.
4. 따라서 루트가 될 수 있는 정점을 하나만 찾을 수 있다면, BFS 따위를 통하여 다른 모든 답을 $O(N)$에 구할 수 있다.

이제 우리는 루트가 될 수 있는 정점 하나를 찾는 데에 집중할 것이다. 조금 더 정확하게, $1$번 정점과 가장 가까우면서 루트가 될 수 있는 정점 $r$을 찾을 것이다. (답이 공집합이 아니라고 가정하고 있음에 유의하라.)

$1$번 정점을 루트로 했을 때, 정점 $v$의 부트리에 $v$와 색이 같은 정점이 있다면, 우리는 $v$를 "충돌 정점"이라 부르자. 만약에 그 어떤 충돌 정점도 존재하지 않는다면, $r = 1$다. 이제 충돌 정점이 있는 경우에 대하여 다음을 관찰하자:

1. 모든 충돌 정점은 $1$번 정점과 정점 $r$을 잇는 경로 위에 존재한다. 만일 그렇지 않다면, 이는 $r$이 답이 될 수 없음을 유도한다.
2. $1$번 정점과 가장 먼 충돌 정점을 $x$라 하자. $r$은 $x$의 부트리에 존재한다.
3. $r$의 부모 정점은 $x$다. $r$의 부모 정점이 $p \ne x$라면, 다음과 같은 모순이 일어난다:
   1. $p \in S$라면, $r, p \in S$가 서로 인접해 있고 $r$은 답이 될 수 있으므로, $p$ 또한 답이 될 수 있다. 따라서 정의에 의해 $r = p$여야 한다.
   2. $p \notin S$라면, $p$와 색이 같은 정점 $v \ne p$가 존재한다. $r$이 답이 될 수 있으므로, $v$는 $p$의 부트리 안에 있어야만 한다. 이 경우, $p$는 충돌 정점이 되므로, 정의에 의해 $x = p$여야 한다.
4. $x$의 부트리에 $x$와 색이 같은 정점은 $r$의 부트리에 존재한다.

이제 위의 모든 내용을 종합하여, 아래의 알고리즘을 시행하자:

1. 한 번의 DFS로 $O(N)$에 정점 $x$를 구한다.
2. 과정 1.에서 충돌 정점이 없었다면, $r = 1$다.
3. 과정 1.에서 충돌 정점이 있었다면, 다음 조건을 만족하는 정점 $y$를 찾아, $r := y$로 설정한다.
   1. $y$는 $x$의 자식.
   2. $y$의 부트리 중 $x$와 색이 같은 정점이 존재.
4. $r$이 답이 될 수 있는지 한 번의 DFS로 $O(N)$에 판별한다.
5. $r$이 답이 될 수 있다면, BFS 등으로 모든 답을 $O(N)$에 구한다.

우리가 논리를 전개하기에 앞서, 우리는 "답이 공집합이 아님"을 가정하였다. 그러나, 답이 공집합이더라도 위의 알고리즘은 과정 4.에 의해 올바른 답을 알려준다. 따라서, 위의 알고리즘은 정당하다.

시간복잡도와 공간 복잡도 모두 $O(N)$다.



### [촛불과 그림자](https://www.acmicpc.net/problem/18190)

#### 개요

출제자 : 윤교준 / 데이터 제작자 : 윤교준<br>운영진의 최단 코드 : 2615 bytes (C++)<br>교내 First Solver : N/A<br>Open First Solver : N/A

> 볼록 다각형 내부에 볼록 다각형이 포함되어 있다.<br>쿼리로 촛불의 위치가 주어질 때, 안쪽 다각형에 의하여 만들어지는 그림자 영역의 넓이를 구하시오.

출제진이 두 명인데, 한 명(본인)은 기하가 세상의 전부라고 생각하고, 또다른 한 명(김세빈)은 기하를 혐오하나 풀라고 하면 군말없이 푸는 사람이다. 그렇다면, 기하 문제가 나온다는 것은 예상 범위 안이라고 생각한다.

교내 대회에서 라이브러리를 미리 준비해서 사용할 수 있게 한 가장 큰 이유가 이 문제의 존재다. '기하 라이브러리로 한 번 풀어볼테면 풀어봐라' 느낌으로 출제했는데, 아무도 기하 라이브러리를 준비하지 않은 점이 조금 아쉽다. 사실 이런 류의 문제가 좋지 않음은 인지하고 있었으나, Open All Solve 방지용으로 출제한 점도 없지 않아 있다.

Open 대회 1위와 2위 수상자는 다른 11개의 문제를 모두 풀고 시간이 남아, 본 문제에도 소스코드를 제출하였으나 아쉽게도 맞지 못하였다. 그들이 제출한 소스 코드를 공개하자면:

`#include<bits/stdc++.h>

using namespace std;

int main() {
    cout << "Hello World!" << endl;
    return 0;
}`<br>tlwpdus의 C++14 코드 (채점 번호 : 16465014)



풀이







