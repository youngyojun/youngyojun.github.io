<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-03-12T15:56:43+09:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Gyojun Youn’s PS Blog</title><subtitle>@youngyojun, @GyojunYoun, and @yclock's PS Blog</subtitle><author><name>Gyojun Youn</name></author><entry><title type="html">ICPC WF 연습 (3/7)</title><link href="http://localhost:4000/icpc/practice/2021/03/08/WF-practice/" rel="alternate" type="text/html" title="ICPC WF 연습 (3/7)" /><published>2021-03-08T23:54:35+09:00</published><updated>2021-03-08T23:54:35+09:00</updated><id>http://localhost:4000/icpc/practice/2021/03/08/WF-practice</id><content type="html" xml:base="http://localhost:4000/icpc/practice/2021/03/08/WF-practice/">&lt;h3 id=&quot;flip-flow&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20906&quot;&gt;Flip Flow&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;모래시계를 시뮬레이션 하는 문제이다.&lt;/p&gt;

&lt;p&gt;시키는 대로 구현하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;ascent-sequences&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19401&quot;&gt;Ascent Sequences&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;다음 조건을 모두 만족하는 길이 $N$의 수열 ${ a_i }$의 가짓수를 구하는 문제이다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 원소는 음이 아닌 정수이다.&lt;/li&gt;
  &lt;li&gt;$a_i \le A_{i-1} + 1$. 여기서, $A_i$는 $a_1 \cdots a_i$에서 증가한 횟수.&lt;/li&gt;
  &lt;li&gt;“201 패턴”이 존재하면 안된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대충 다음과 같은 생각을 하였다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;문제에서 찾고자 하는 수열은 다음 두 수열을 적당히 합쳤다고 생각해도 된다:
    &lt;ul&gt;
      &lt;li&gt;$a_i$는 $\max \left( a_1, a_2, \cdots, a_{i-1} \right)$ 혹은 이보다 하나 작은 값.&lt;/li&gt;
      &lt;li&gt;계단 형태로 감소하는 수열&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 수열 모두 적당한 DP로 해결할 수 있다. 나는 $O\left( N^4 \right)$ 크기의 DP를 생각하였다.&lt;/li&gt;
  &lt;li&gt;이제 적당히 합쳐서 가짓수를 세면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만, 결국 풀지 못했다. 더 많은 관찰이 필요한 듯 하다.&lt;/p&gt;

&lt;h3 id=&quot;buggy-combination-lock&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19402&quot;&gt;Buggy Combination Lock&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;두 개의 수열 ${ a_i }$, ${ b_i }$가 있다. 다음과 같은 연산을 사용하여, 수열 ${ a_i }$를 ${ b_i }$로 바꿀 때, 연산 사용의 최소 횟수를 구하는 문제이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$a_i$과 $a_{i+1}$에 모두 $1$을 더하거나, $-1$을 더한다.
    &lt;ul&gt;
      &lt;li&gt;Index는 modulo $N$, 원소의 값은 modulo $M$에서 생각한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Index $i$에 대하여 적용한 값을 $v_i$라고 하자. $-M &amp;lt; v_i &amp;lt; M$이며, $b_i = a_i + v_i + v_{i-1}$를 만족하면서 $\sum_i \left \lvert \min \left( v_i, M - v_i \right) \right \rvert$가 최소가 되는 ${ v_i }$를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;식을 조금 변형하면, $v_{i-1} + v_i = b_i - a_i =: c_i$를 얻을 수 있다. 즉, $v_i = A_i v_0 + B_i$ 형태로 나타낼 수 있으며, 또한 $A_i = \pm 1$가 성립한다.&lt;/p&gt;

&lt;p&gt;이제, Case를 나누자:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$A_0 = 1$인 경우,
    &lt;ul&gt;
      &lt;li&gt;$B_0 \ne 0$이라면, 해가 존재하지 않는다.&lt;/li&gt;
      &lt;li&gt;$B_0 = 0$이라면, 모든 $v_0$에 대해 해가 존재한다. (즉, 해가 총 $M$개 존재한다.)
        &lt;ul&gt;
          &lt;li&gt;$f\left( v_0 \right) := \sum_i \left \lvert \min \left( v_i, M - v_i \right) \right \rvert$라고 하자.&lt;/li&gt;
          &lt;li&gt;함수 $f$는 $N$개의 Piecewise-linear function의 합으로 표현할 수 있다.&lt;/li&gt;
          &lt;li&gt;따라서, $f$의 모든 local minima와 maxima를 전부 알아낼 수 있다.&lt;/li&gt;
          &lt;li&gt;즉, $\min f$를 $O \left( N \lg N \right)$에 구할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$A_0 = -1$인 경우,
    &lt;ul&gt;
      &lt;li&gt;$v_0 = -v_0 + B_0$, $2 v_0 = B_0$이므로, 가능한 $v_0$의 값은 최대 두 개이다.&lt;/li&gt;
      &lt;li&gt;가능한 모든 $v_0$에 대해, $\sum_i \left \lvert \min \left( v_i, M - v_i \right) \right \rvert$의 값을 계산하면 충분하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서, $O\left( N \lg N \right)$의 시간 복잡도로 답을 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;틀리기 쉬운 요소가 상당히 많았고, 나는 그런 부분에 대해 모두 한 번씩 틀렸었다.&lt;/p&gt;

&lt;h3 id=&quot;cyclic-shifts&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19403&quot;&gt;Cyclic Shifts&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;문자열 $S= s_1 s_2 \cdots s_k$에 대해, 문자열 $s_{i+1} \cdots s_k s_1 \cdots s_i$가 사전순으로 최소가 되는 $i$ 중, 가장 작은 $i$를 Cyclic shift라고 정의하자. 길이 $N$의 문자열 $S$가 주어질 때, 모든 Prefix에 대하여 Cyclic shift의 값을 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;찾아보니 논문이다. 길이 $1, 2, \cdots, K$인 Prefix의 Cyclic shift 값을 모두 알고 있을 때, 단 세 번의 추가 비교 연산만으로 $K+1$-Prefix의 Cyclic shift 값을 알아낼 수 있다고 한다.&lt;/p&gt;

&lt;h3 id=&quot;exclusive-training&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19405&quot;&gt;Exclusive Training&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$N$개의 벡터 $\left( r_i, p_i, a_i, b_i \right)$가 주어진다. 각 $i$에 대하여, 다음 최댓값을 구하는 문제이다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$r \le r_i$, $a_i \le d \le b_i$인 $(r, d)$를 고정하자.&lt;/li&gt;
  &lt;li&gt;$r_j \le r$, $a_j \le d \le b_j$를 모두 만족하는 모든 $j \ne i$에 대하여, $\sum_j p_j$의 최댓값.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저, $r_i$가 서로 다르므로, $r_i$의 오름차순으로 정렬하자.&lt;/p&gt;

&lt;p&gt;Key가 $d$인 Segment Tree를 생각하자. 이 Segment Tree는 다음 연산을 지원한다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구간에 $p_i$ 더하기.&lt;/li&gt;
  &lt;li&gt;각 $d$에 대하여, 지금까지 자신이 가졌던 값의 최댓값을 $mx(d)$라고 하자. 구간에서 $mx(d)$의 최댓값 구하기.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$r_i$가 작은 $i$부터 차례대로 보면서, 구간 $\left[ a_i, b_i \right]$에서 최댓값이 문제의 답이 된다. 문제의 답을 구한 후, 구간 $\left[ a_i, b_i \right]$에 $p_i$를 더해주면 된다.&lt;/p&gt;

&lt;p&gt;Segment Tree의 이러한 연산은 Lazy Propagation Technique를 이용하면 효율적으로 처리할 수 있다. Propagation 정보로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구간에 더해주어야 하는 값&lt;/li&gt;
  &lt;li&gt;이 구간에 더해주어야 하는 값의 Prefix sum의 최댓값 ($mx(d)$에 더해주어야 하는 값)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;을 들고 있어야 한다.&lt;/p&gt;

&lt;p&gt;전체 시간 복잡도는 $O \left( N \lg N \right)$, 공간 복잡도는 $O \left( N \right)$이다.&lt;/p&gt;

&lt;p&gt;상당히 재미있는 테크닉이다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="ICPC" /><category term="연습" /><summary type="html">Flip Flow</summary></entry><entry><title type="html">ICPC WF 연습 (3/4)</title><link href="http://localhost:4000/icpc/practice/2021/03/06/WF-practice/" rel="alternate" type="text/html" title="ICPC WF 연습 (3/4)" /><published>2021-03-06T00:19:21+09:00</published><updated>2021-03-06T00:19:21+09:00</updated><id>http://localhost:4000/icpc/practice/2021/03/06/WF-practice</id><content type="html" xml:base="http://localhost:4000/icpc/practice/2021/03/06/WF-practice/">&lt;h3 id=&quot;circle&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7115&quot;&gt;Circle&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;격자판에 원을 그렸을 때, 원이 지나는 격자의 개수를 세는 문제이다.&lt;/p&gt;

&lt;p&gt;효율적으로 잘 세면 된다.&lt;/p&gt;

&lt;p&gt;이게 왜 브론즈 1 문제인지 전혀 모르겠다.&lt;/p&gt;

&lt;h3 id=&quot;balance&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19043&quot;&gt;Balance&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$N \times N$ 행렬 $B_{i, j}$가 다음 조건을 만족하면, Balanced라고 하자:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 $i$, $j$에 대하여, $B _{i-1, j-1} + B _{i, j} = B _{i-1, j} + B _{i, j-1}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$N \times N$ 행렬 $A_{i, j}$가 주어질 때, 각 원소가 $A _{i, j}$ 이상이면서 Balanced한 행렬 중, 원소의 합이 최소인 행렬을 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;위의 식을 다음과 같이 변형하자: $B _{i-1, j} - B _{i-1, j-1} = B _{i, j} - B _{i, j-1}$&lt;/p&gt;

&lt;p&gt;따라서, Balanced한 행렬은 항상 다음과 같이 생성할 수 있다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 수열 $C$, $D$에 대하여, $B _{i, j} = C _i + D _j$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, $A _{i, j} \le C _i + D _j$의 부등식을 모두 만족하면서, $\sum _i C _i + \sum _j D _j$가 최소가 되는 두 수열 $C$, $D$를 구하면 된다.&lt;/p&gt;

&lt;p&gt;따라서, LP 문제를 풀면 되고, Simplex Algorithm을 적용하면 된다.&lt;/p&gt;

&lt;p&gt;나는, Simplex Algorithm을 적용할 때, 행렬의 계수가 음이 아닌 수만 되는 줄 알고 있어서 오래 걸렸다. 사실은 음수도 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;entanglement&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19044&quot;&gt;Entanglement&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;모르겠다.&lt;/p&gt;

&lt;p&gt;답이 0인지 아닌지 판별하는 것도 2-SAT을 열심히 풀어야 가능하다.&lt;/p&gt;

&lt;p&gt;가짓수를 어떻게 셀까…?&lt;/p&gt;

&lt;h3 id=&quot;origami&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19049&quot;&gt;Origami&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;각 격자에 알파벳이 적혀 있는 $N \times M$ 격자판 모양의 색종이가 있다.&lt;/p&gt;

&lt;p&gt;만일, 어떤 격자선을 기준으로 색종이를 (넓은 부분 위에 좁은 부분이 오도록) 접었을 때, 포개어지는 부분이 서로 일치한다면, 그 격자선을 따라 접을 수 있다.&lt;/p&gt;

&lt;p&gt;색종이를 마구 접었을 때, 최종 상태로 가능한 경우의 수를 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;먼저, 가로축과 세로축을 접는 것은 서로 독립이다. 따라서, 문제를 1차원으로 변형할 수 있다.&lt;/p&gt;

&lt;p&gt;1차원 색종이를 접었을 때, 최종 상태로 가능한 구간의 수를 구하여야 한다. 나는 엄밀하게 증명하지 않았지만, $a$가 구간의 왼쪽 끝으로 가능하고, $b$가 구간의 오른쪽 끝으로 가능하다면, 구간 $[a, b]$는 항상 최종 상태로 가능하다.&lt;/p&gt;

&lt;p&gt;따라서, Manacher Algorithm을 이용하여, 각 축을 언제부터 접을 수 있는지 구해놓았다면, 구간의 왼쪽 끝과 오른쪽 끝의 후보 지점을 모두 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;전체 시간 복잡도는 $O(NM)$이다.&lt;/p&gt;

&lt;h3 id=&quot;xormites&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19054&quot;&gt;Xormites&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$N$개의 수 $A _1, \cdots, A _N$가 일렬로 놓여져 있다. 두 사람이 번갈아가며, 양 끝에 놓여진 수 중 하나를 골라 가져간다. 가져간 수의 xor가 큰 사람이 이길 때, 승자를 판별하는 문제이다.&lt;/p&gt;

&lt;p&gt;먼저, $A _1 \oplus A _2 \oplus \cdots \oplus A _N$의 값을 계산하자. 이 값이 0이라면, 두 사람은 항상 비긴다.&lt;/p&gt;

&lt;p&gt;이 값이 0이 아니라면, 가장 큰 bit $X$를 생각하자. 수열 $A$에서 게임은, $A’ _i := A _i \land X$인 수열 $A’$에서 하는 게임과 동치이다. 따라서, 01-string으로 문제를 환원할 수 있다.&lt;/p&gt;

&lt;p&gt;먼저, $N$가 짝수라면, 선수가 승리한다. 왜냐하면, 선수는 “모든 짝수번째 수를 가져가거나”, “모든 홀수번째 수를 가져가는” 전략을 선택할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;이제, $N$가 홀수라고 하자. 처음에 선수는 절대로 0을 가져가면 안 된다.&lt;/p&gt;

&lt;p&gt;선수가 어떤 1을 가져갔다고 하자. 이제부터, 선수는 항상, 방금 전 후수가 가져간 수와 동일한 수를 가져가야 한다. 만일, 이를 실패한다면, 남은 수의 개수가 짝수이고, 남은 수의 xor sum가 1이기 때문에, 후수가 승리하는 전략이 존재하게 된다.&lt;/p&gt;

&lt;p&gt;선수가 후수의 전략을 Defence할 수 있는 수열은, 항상 다음과 같은 형태를 가진다: $S aa bb cc dd \cdots \overline{S}$&lt;/p&gt;

&lt;p&gt;여기서, $\overline{S}$는 문자열 $S$를 뒤집은 것이다. Exchange Argument를 이용해서 증명하고 싶었는데 실패했다. Naive하게 전탐색을 했는데 반례가 없어서 믿고 풀었다.&lt;/p&gt;

&lt;p&gt;전체 시간 복잡도는 $O(N)$이다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="ICPC" /><category term="연습" /><summary type="html">Circle</summary></entry><entry><title type="html">ICPC WF 연습 (2/14)</title><link href="http://localhost:4000/icpc/practice/2021/02/15/WF-practice/" rel="alternate" type="text/html" title="ICPC WF 연습 (2/14)" /><published>2021-02-15T09:00:00+09:00</published><updated>2021-02-15T09:00:00+09:00</updated><id>http://localhost:4000/icpc/practice/2021/02/15/WF-practice</id><content type="html" xml:base="http://localhost:4000/icpc/practice/2021/02/15/WF-practice/">&lt;h3 id=&quot;multi-key-sorting&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/3340&quot;&gt;Multi-key Sorting&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;문제 요약은 생략한다.&lt;/p&gt;

&lt;p&gt;마지막 수만 유효하다. 마지막 수만 잘 남겨서 출력하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;chuck&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2901&quot;&gt;CHUCK&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;3시간 동안 잘못된 풀이를 가지고 맞왜틀을 시전하다 던졌다.&lt;/p&gt;

&lt;p&gt;나는, $nR$ 혹은 $nC$개의 수의 부호만 바꿀 수 있는 줄 알았다. 하지만, 실제로는 $n_1 R + n_2 C$개의 수의 부호를 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;구현은 참 재미있을 것 같다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="ICPC" /><category term="연습" /><summary type="html">Multi-key Sorting</summary></entry><entry><title type="html">ICPC WF 연습 (2/11)</title><link href="http://localhost:4000/icpc/practice/2021/02/12/WF-practice/" rel="alternate" type="text/html" title="ICPC WF 연습 (2/11)" /><published>2021-02-12T09:00:00+09:00</published><updated>2021-02-12T09:00:00+09:00</updated><id>http://localhost:4000/icpc/practice/2021/02/12/WF-practice</id><content type="html" xml:base="http://localhost:4000/icpc/practice/2021/02/12/WF-practice/">&lt;h3 id=&quot;hard-refactoring&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13996&quot;&gt;Hard Refactoring&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;부등식 여러 개가 주어지면, 이를 동치이면서 최대한 짧은 하나의 부등식으로 표현하는 문제이다.&lt;/p&gt;

&lt;p&gt;그냥 열심히 짜면 된다.&lt;/p&gt;

&lt;h3 id=&quot;bin&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18743&quot;&gt;Bin&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;각 정점에 대해 왼쪽 부트리의 크기가 오른쪽 부트리의 크기 + $K$ 이하인, $N$개의 잎을 가진 Full binary tree의 개수를 세는 문제이다.&lt;/p&gt;

&lt;p&gt;$N = n$일 때의 답을 $D_n$이라고 하자. 자명하게, $D_0 = D_1 = 1$이다.&lt;/p&gt;

&lt;p&gt;다음과 같은 점화식은 쉽게 관찰할 수 있다: $D_n = \sum_{l = 1}^{ \lfloor { (n+K) / 2 } \rfloor } D _l D _{n - l}$&lt;/p&gt;

&lt;p&gt;$K$가 아주 작으므로, 식을 다음과 같이 변형할 수 있다: $D_n = \frac{1}{2} \sum_{l = 1}^{ n } D _l D _{n - l} + O(K)\text{개의 항}$&lt;/p&gt;

&lt;p&gt;이제, Online FFT Technique을 적용하면, $O\left( NK \lg N \right)$에 해결할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;cat&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18744&quot;&gt;Cat&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;두 문자열 $A$, $B$가 주어질 때, $A[a \cdots ] + B[ \cdots b]$ 꼴의 서로 다른 문자열의 개수를 세는 문제이다.&lt;/p&gt;

&lt;p&gt;SA를 이용하면 풀린다고 한다. 나는 모르겠다.&lt;/p&gt;

&lt;h3 id=&quot;exp&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18746&quot;&gt;Exp&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$K+1$개의 음이 아닌 실수 $P_0, P_1, \cdots, P_K$가 주어질 때, 다항식 $\left( P_0 + P_1 x + P_2 x^2 + \cdots + P_K x^K \right)^N$에서, $x^0, x^1, \cdots, x^{T-1}$의 계수를 모두 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;구해야 하는 다항식을 $P(x)$라고 하자. 또한, $P^N = c_0 x^0 + c_1 x^1 + \cdots + c_T x^T + \cdots $라고 하자.&lt;/p&gt;

&lt;p&gt;$N P^N P’ = \left( P^N \right)’ P$이므로, 계수 비교를 하면, $c_i$를 $c _{i-K-1}, \cdots, c _{i-1}$의 선형 결합으로 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서, 전체 시간 복잡도는 $O\left( TK \right)$이다.&lt;/p&gt;

&lt;h3 id=&quot;grp&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18748&quot;&gt;Grp&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$N$개의 알파벳 중 $K$개 이하의 알파벳을 뽑아 만들 수 있는 모든 집합을, 다음 조건을 만족하도록 최소 개수의 그룹으로 나누어야 한다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 집합은 정확하게 하나의 그룹에만 속한다.&lt;/li&gt;
  &lt;li&gt;하나의 그룹에 속하는 모든 집합은 서로소이다.&lt;/li&gt;
  &lt;li&gt;하나의 그룹에 속하는 모든 집합의 크기의 합은 $K$ 이하이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$K$가 홀수일 때를 풀어보자. 답의 자명한 상한을 생각하자. 크기가 $K/2$ 초과인 집합은 같은 그룹에 속할 수 없다. 따라서, 답은 $\binom{N}{(K+1)/2} + \cdots + \binom{N}{K}$보다 작을 수 없다.&lt;/p&gt;

&lt;p&gt;이제, 제시한 상한을 답으로 가지는 해를 만들자. $1 \le x &amp;lt; K/2$이면 $\binom{N}{x} \le \binom{N}{K-x}$이므로, 크기가 $x$인 집합과 $K-x$인 집합 사이에 Matching을 구하면 된다.&lt;/p&gt;

&lt;p&gt;이제, $K$가 짝수일 때를 관찰하자. 크기가 $K/2$인 집합을 두 개씩 묶어 최대한 많은 그룹을 만들어야 한다. 이는 General Matching을 구하면 해결할 수 있다. 놀랍게도, $N \le 17$이면, 항상 Perfect Matching이 존재해서, 이 논리는 유효하다.&lt;/p&gt;

&lt;p&gt;이를 잘 구현하면, 모든 입력에 대해 상당히 빠른 시간 안에 답이 잘 나온다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="ICPC" /><category term="연습" /><summary type="html">Hard Refactoring</summary></entry><entry><title type="html">ICPC WF 연습 (2/8)</title><link href="http://localhost:4000/icpc/practice/2021/02/10/WF-practice/" rel="alternate" type="text/html" title="ICPC WF 연습 (2/8)" /><published>2021-02-10T06:11:24+09:00</published><updated>2021-02-10T06:11:24+09:00</updated><id>http://localhost:4000/icpc/practice/2021/02/10/WF-practice</id><content type="html" xml:base="http://localhost:4000/icpc/practice/2021/02/10/WF-practice/">&lt;h3 id=&quot;pizza&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20660&quot;&gt;Pizza&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Boolean array 가지고 노는 문제. 나는 bitset의 &amp;amp; operator로 풀어보았다.&lt;/p&gt;

&lt;p&gt;2분 AC.&lt;/p&gt;

&lt;h3 id=&quot;3d-histogram&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20197&quot;&gt;3D Histogram&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;크기가 $1 \times A_i \times B_i$인 블록 $N$개로 이루어진 3차원 히스토그램이 주어진다. 이 히스토그램에 포함되는, 부피가 가장 큰 직육면체의 부피를 계산하는 문제이다.&lt;/p&gt;

&lt;p&gt;2차원 히스토그램에서 최대 넓이 직사각형을 선형에 푸는 아이디어를 적용해보았다. 하지만, 잘 안 되는 듯 하다.&lt;/p&gt;

&lt;p&gt;분할 정복 기법을 적용하자. 기준면에서 보이는 단면의 형태를 계산하자. 이는 (깊이, 높이, 너비) 형태로 나올 것이다.&lt;/p&gt;

&lt;p&gt;이제, ‘깊이’를 index, (높이, 너비)의 point를 key로 생각하자. index가 증가함에 따라, (높이, 너비)의 point는 “증가하는” 형태이며, 또한, 높이와 너비의 곱 또한 증가함을 관찰하자.&lt;/p&gt;

&lt;p&gt;기준면 오른쪽의 블록 하나를 잡자. 부피를 최대로 만드는 기준면 왼쪽의 블록을 찾아야 한다. (높이, 너비) point를 좌표평면에 찍어놓고 관찰하면, index가 어떤 구간에 속하는 점에 대해, Convex hull trick 형태의 문제를 해결해야 함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;Convex hull trick의 deque를 Segment tree 형태로 구축하면, 문제를 효율적으로 해결할 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;구현을 아주 잘 하면, 분할 정복에서 소요되는 시간은 $O\left( N \lg N \right)$이다. 따라서, 전체 문제를 $O\left( N \lg^2 N \right)$에 해결할 수 있다. 3시간 AC.&lt;/p&gt;

&lt;h3 id=&quot;tenis&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20199&quot;&gt;Tenis&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;코트가 두 개일 때를 풀어보았다. 세 개일 때에는 정말 역겨울 거라고 예상하고 안 풀었다.&lt;/p&gt;

&lt;h3 id=&quot;euklid&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20202&quot;&gt;Euklid&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;두 자연수 $g$, $h$가 주어질 때, $\gcd (a, b) = g$, $R(a, b) = h$인 자연수쌍 $(a, b)$를 아무거나 하나 찾는 문제이다.&lt;/p&gt;

&lt;p&gt;문제에서 주어진 함수 $R$을 해석해야 한다. $R(a, b)$는 $a$를 $b$진법으로 썼을 때에 가장 큰 자릿수가 $a’$라면, $R(a, b) = R(b, a’)$로 Reduct되는 함수이다.&lt;/p&gt;

&lt;p&gt;나의 접근은 다음과 같다. $h = R(h, 1)$이다. 이제, $R(h, 1) = R(gk, h)$인 $k$를 찾을 것이다.&lt;/p&gt;

&lt;p&gt;$g \le h^n$을 만족하는 최소 $n$을 찾자. 비둘기집 원리에 의하여, $h$진법으로 $n+1$자리 수이면서, 가장 큰 자릿수가 1이고, 또한 $g$의 배수인 수가 항상 존재한다. 이 수를 $gk$라고 두면 된다.&lt;/p&gt;

&lt;p&gt;$h = R(gk, h)$까지 왔다. $R(gk, h) = R(x, gk)$임과 동시에 $\gcd (x, gk) = g$인 $x$를 찾아야 한다.&lt;/p&gt;

&lt;p&gt;먼저, $k = 1$라면, $R(g, h) = R(gh, g)$이며, $\gcd (gh, g) = g$다. 따라서, $x = gh$.&lt;/p&gt;

&lt;p&gt;$k &amp;gt; 1$라면, $R(gk, h) = R(ghk + g, gk)$이며, $\gcd (ghk + g, gk) = g$다. 따라서, $x = ghk + g$.&lt;/p&gt;

&lt;p&gt;따라서, $O(1)$에 문제를 해결할 수 있다. 46분 AC.&lt;/p&gt;

&lt;h3 id=&quot;false-faces&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7875&quot;&gt;(False) faces&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$N \times N$ Binary matrix $M$가 주어질 때, $M$의 permanent $\text{perm } M$가 4의 배수인지 판별하는 문제이다.&lt;/p&gt;

&lt;p&gt;먼저, Determinant $\det M$과 다르게, $\text{perm } M$을 Polynomial time에 계산하는 것은 P = NP보다 더 어려운 문제임이 알려져 있다. 따라서, 조금은 tricky하게 문제를 접근해야 한다.&lt;/p&gt;

&lt;p&gt;$-1 \equiv 1 \mod 2$이므로, $\det M \equiv \text{perm } M \mod 2$이다. 따라서, $\det M \equiv 0 \mod 2$라고 가정해도 좋다.&lt;/p&gt;

&lt;p&gt;선형대수학의 기본 정리에 따르면, $\mathbb{Z}_2^N$에서 $M\mathbf{v} = 0$인 비자명한 해 $\mathbf{v}$가 존재한다. 이러한 벡터를 구하자.&lt;/p&gt;

&lt;p&gt;$\mathbf{w} := \sum_ {i} v_i \mathbf{m}_i$라고 하자. $\mathbf{w}$의 모든 성분은 짝수이다. 편의상, $\mathbf{w}/2 := \frac{1}{2} \mathbf{w}$라고 하자.&lt;/p&gt;

&lt;p&gt;$\text{perm } \left( \mathbf{w}, \mathbf{m}_ 2, \mathbf{m}_ 3, \cdots, \mathbf{m}_ N \right) = \sum_ {i} v_ i \text{ perm } \left( \mathbf{m}_ i, \mathbf{m}_ 2, \mathbf{m}_ 3, \cdots, \mathbf{m}_ N \right)$이다. $v_1 = 1$라면, 이러한 식을 이용하여, $\text{perm } M = \text{perm } \left( \mathbf{m}_ 1, \mathbf{m}_ 2, \cdots, \mathbf{m}_ N \right)$의 값을 알아낼 수 있을 것이다. $\mathbf{v}$가 Non-zero이므로, $v_i = 1$인 $i$가 하나 이상 존재하기에, 이러한 논리는 유효하다.&lt;/p&gt;

&lt;p&gt;이제, 재미있는 관찰을 하자. $\text{perm } \left( \mathbf{w}, \mathbf{m}_ 2, \mathbf{m}_ 3, \cdots, \mathbf{m}_ N \right) = 2 \text{ perm } \left( \mathbf{w}/2, \mathbf{m}_ 2, \mathbf{m}_ 3, \cdots, \mathbf{m}_ N \right)$이다. 따라서, $\det \left( \mathbf{w}/2, \mathbf{m}_ 2, \mathbf{m}_ 3, \cdots, \mathbf{m}_ N \right) \mod 2$를 계산하면 충분하다.&lt;/p&gt;

&lt;p&gt;비슷하게, $\text{perm } \left( \mathbf{m}_ 1, \mathbf{m}_ 2, \mathbf{m}_ 3, \cdots, \mathbf{m}_ N \right)$도 벡터 $\mathbf{m}_i$가 두 번 들어가 있는 형태이므로 짝수이다. 따라서, Determinant로 치환해서 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;이대로 구현하면, Determinant를 $O\left( N^2 \right)$번 계산해야 한다. 하지만, 창의성을 발휘하면, Determinant를 $O(N)$번만 계산해서 잘 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;나는 Gaussian elimination을 총 $N-1$번 수행한다. 전체 시간복잡도는 $O\left( \frac{N^4}{32} \right)$이다. BOJ는 TL가 1초로 아주 빡빡하게 설정되어 있어, TL 연장 요청을 넣었다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="ICPC" /><category term="연습" /><summary type="html">Pizza</summary></entry><entry><title type="html">ICPC WF 연습 (2/6)</title><link href="http://localhost:4000/icpc/practice/2021/02/09/WF-practice/" rel="alternate" type="text/html" title="ICPC WF 연습 (2/6)" /><published>2021-02-09T05:27:12+09:00</published><updated>2021-02-09T05:27:12+09:00</updated><id>http://localhost:4000/icpc/practice/2021/02/09/WF-practice</id><content type="html" xml:base="http://localhost:4000/icpc/practice/2021/02/09/WF-practice/">&lt;h3 id=&quot;chess-puzzle&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/5239&quot;&gt;Chess Puzzle&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;2분 30초 AC.&lt;/p&gt;

&lt;p&gt;전성기 때 나라면 1분 안에 풀었을 텐데… 열심히 해야지.&lt;/p&gt;

&lt;h3 id=&quot;squared-word&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8300&quot;&gt;Squared Word&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;길이 $N$의 문자열 $S$가 주어진다. 제곱 문자열 $L^2$가 $S$에 포함될 때, 문자열 $L$의 최대 길이를 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;$L^2$가 $S$에 포함된다는 것은, 어떤 $1 \le i &amp;lt; N$가 존재하여, $S[1 \cdots i]$와 $S[i+1 \cdots N]$ 모두에 각각 $L$가 포함됨과 동치이다.&lt;/p&gt;

&lt;p&gt;따라서, 모든 $i$에 대하여, $S[1 \cdots i]$와 $S[i+1 \cdots N]$의 LCS를 구한 후, 이 값의 최댓값이 문제의 답이 된다.&lt;/p&gt;

&lt;p&gt;나는 $O(N)$번 LCS를 계산하는 과정을 $O\left( N^2 \right)$로 최적화하려고 고민을 아주 많이 했었다… tlwpdus도 이렇게 풀었고…&lt;/p&gt;

&lt;p&gt;그런데, bitset을 이용하면, LCS를 $O\left( \frac{ N^2 }{32} \right)$에 해결할 수 있다고 한다. Naive 알고리즘이 $O\left( \frac{N^3}{32} \right)$인데 $O\left( N^2 \right)$ tlwpdus 풀이랑 시간이 똑같다. 상당히 큰 충격.&lt;/p&gt;

&lt;h3 id=&quot;응급센터&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2489&quot;&gt;응급센터&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;대충 뚝딱뚝딱 선형에 풀리는 것 같은데 증명을 못 하겠다.&lt;/p&gt;

&lt;h3 id=&quot;cliquers-strike-back&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8357&quot;&gt;Cliquers Strike Back&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;두 자연수 $N$, $M$가 주어진다. Labeling이 되어 있는 $N$개의 정점을 몇 개의 그룹으로 나누는 경우의 수를 ‘지수’로 가지고, 밑이 $M$인 수를 $P := 10^9 - 401$로 나눈 나머지를 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;이 문제는 옛날 폴란드 문제이다. 풀이를 만들고 어떻게든 끼워넣어서 문제를 만들었겠구나 생각하면서 문제를 풀었다.&lt;/p&gt;

&lt;p&gt;먼저, $P$는 소수이다. $N$-Labeling 경우의 수가 $D_N$라고 하자. 우리는 $M^{D_N} \mod P$를 구해야 한다. 페르마 소정리에 따라, $D_N \mod P-1$을 알아내면 된다.&lt;/p&gt;

&lt;p&gt;이제, 가장 어려운 접근을 해야 한다. $P-1$의 소인수분해를 시도하자. $P-1 =2 \times 13 \times 5281 \times 7283$. 소인수가 모두 만 이하로 적당히 작고, 네 개의 소인수가 모두 다르다는 점을 주목해야 한다. 네 개의 소인수를 $Q_i$라고 하자. $D_N \mod Q_i$의 값을 모두 알아낸 후, 중국인의 나머지 정리를 통해 원래의 값을 복원하자.&lt;/p&gt;

&lt;p&gt;$D_N$에 대한 점화식은 쉽게 세울 수 있다. $D_0 = 1$, $D_{N+1} = \sum_{k=0}^{N} \binom{N}{k} D_k$. 어디서 많이 본 형태가 나온다. $f(x) := e^{e^{x-1}}$로 정의한다면, $f(x) = \sum_{k = 0}^{\infty} \frac{x^k}{k !}$임을 알 수 있다. 즉, 열심히 잘 하면, $D_N$의 값을 $O( N \lg N )$에 알아낼 수 있다.&lt;/p&gt;

&lt;p&gt;이제, 적당히 작은 소수 $Q$에 대하여, $D_N \mod Q$의 값을 효율적으로 계산하는 방법을 알아내보자. 점화식을 열심히 관찰하면, $D_{N + Q} \equiv D_N + D_{N+1} \mod Q$임을 알 수 있다. 이제, 아주 열심히 식 전개를 하면, $D_N$의 값을 $D_0, \cdots, D_{Q-1}$의 선형 결합으로 표현할 수 있다. 이 과정의 시간 복잡도는 $O\left( \frac{ Q \lg_Q^2 N }{ 2 } \right)$이다.&lt;/p&gt;

&lt;p&gt;이 긴 관찰을 모두 해냈다면, TL가 1초인 문제를 960ms의 실행 시간으로 해결할 수 있다. 역시 폴란드..! 2시간 40분 AC.&lt;/p&gt;

&lt;h3 id=&quot;glorious-brilliance&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19438&quot;&gt;Glorious Brilliance&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;정점 $N$개, 간선 $M$개인 그래프가 주어진다. 각 정점의 색칠 여부가 주어진다. 하나의 간선을 선택하면, 그 간선 양 끝의 정점을 서로 바꿀 수 있다. 같은 색을 가지는 정점이 서로 이웃하지 않도록 하기 위하여, 필요한 ‘간선 Swap’ 연산의 최소 횟수를 구하고, 그러한 방법을 출력하는 문제이다.&lt;/p&gt;

&lt;p&gt;그래프가 bipartite하지 않는다면, 답은 없다. 그래프가 $V_1 - V_2$ bipartite graph라고 하자. 색칠된 정점을 모두 $V_1$로 옮기는 문제로 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;$V_1$의 각 정점에서 $V_2$의 각 정점으로 가는 최단 경로의 길이를 행렬로 나타내자. 이 행렬에서 Hungarian algorithm을 돌리면 문제를 해결할 수 있다. 역추적도 힘들지만 된다.&lt;/p&gt;

&lt;p&gt;하지만, 시간 복잡도가 $O\left( N^3 \right)$이라서, 시간 초과 판정을 받을 것 같다. 입력의 크기 제한이 있고, 이 크기는 $O\left( N + M \right)$기 때문에, $O \left( NM \right)$으로 풀어야 하는 것 같은데, 잘 모르겠다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="ICPC" /><category term="연습" /><summary type="html">Chess Puzzle</summary></entry><entry><title type="html">ICPC WF 연습 (2/3)</title><link href="http://localhost:4000/icpc/practice/2021/02/04/WF-practice/" rel="alternate" type="text/html" title="ICPC WF 연습 (2/3)" /><published>2021-02-04T10:20:27+09:00</published><updated>2021-02-04T10:20:27+09:00</updated><id>http://localhost:4000/icpc/practice/2021/02/04/WF-practice</id><content type="html" xml:base="http://localhost:4000/icpc/practice/2021/02/04/WF-practice/">&lt;h3 id=&quot;장난감-경주&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19592&quot;&gt;장난감 경주&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;부등식을 가지고 노는 문제이다.&lt;/p&gt;

&lt;p&gt;브론즈 문제인데 10분 넘게 걸렸다. 왜인지는 잘 모르겠다… 13분 AC.&lt;/p&gt;

&lt;h3 id=&quot;the-shortest-period&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8285&quot;&gt;The Shortest Period&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;길이 $N$인 문자열 $S$에서 하나의 문자를 지웠을 때 얻어지는 문자열의 주기의 최솟값을 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;문자열 $S[1 \cdots N]$의 주기가 $d$라는 것은, $S[1 \cdots N-d] = S[d+1 \cdots N]$과 동치이다.&lt;/p&gt;

&lt;p&gt;이제, 원래 문제로 돌아가서, $S$에서 하나의 문자를 지워서, 길이 $L$의 Prefix와 Suffix가 서로 같도록 만들 수 있는지 판별해보자. 다음 네 가지 경우를 고려하면 된다: ($x$번째 문자를 지운다고 하자.)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$S[1 \cdots L] = S[N-L+1 \cdot N]$ $(L &amp;lt; x &amp;lt; N-L+1)$&lt;/li&gt;
  &lt;li&gt;$S[1 \cdots L] = S[N-L \cdots N]$ $(\max(L+1, N-L) \le x \le N)$&lt;/li&gt;
  &lt;li&gt;$S[1 \cdots L+1] = S[N-L+1 \cdots N]$ $(1 \le x \le \min(L+1, N-L))$&lt;/li&gt;
  &lt;li&gt;$S[1 \cdots L+1] = S[N-L \cdots N]$ $(N-L \le x \le L+1)$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;먼저, 부분문자열의 동일 여부 판별은 Hashing을 이용하자. $O(N^2)$번의 비교가 이루어지므로, $10^9$-scale의 소수 두 개를 이용해야 안전하다.&lt;/p&gt;

&lt;p&gt;Case 1은 아주 쉽다. Case 2, 3도 적당한 이분 탐색으로 $x$를 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;Case 4가 이 문제에서 가장 어려운 부분이다. Case 2, 3과 동일한 아이디어를 이용하면, $x$로 가능한 Indices의 범위가 나온다. 이제, 적당히 문제를 변형하면, 다음과 같이 문제가 환원된다:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$N$개의 공이 일렬로 배열되어 있다. 각 공의 색은 빨강 혹은 파랑이다. 함수 $f$를 적절히 호출하여, 연속한 $K$개의 빨간 공이 존재하는지 판별하시오.&lt;/p&gt;

  &lt;p&gt;함수 $f(s, e)$는 $s$번째 공부터 $e$번째 공까지 모두 빨간 공인지 여부를 반환한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 문제는 함수 $f$를 $O\left( \frac{N}{K} \lg K \right)$번만 호출해서 해결할 수 있다. $N$개의 공을 $K$개씩 끊어 $O\left( \frac{N}{K} \right)$개의 버킷을 만든 후, 각 버킷에 대해 “왼쪽부터 연속한 빨간 공의 개수”와 “오른쪽부터 연속한 빨간 공의 개수”를 이분 탐색으로 세어주면 된다.&lt;/p&gt;

&lt;p&gt;환원된 문제의 아이디어를 잘 적용하면, Case 4를 $O\left( \frac{N}{L} \lg L \right)$에 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서, 전체 문제를 $O\left( \sum_{L} \frac{N}{L} \lg L \right) = O\left( N \lg^2 N \right)$에 해결할 수 있다. 2시간 AC.&lt;/p&gt;

&lt;p&gt;dotorya는 Suffix Array를 이용해서 풀었다. 어떻게…?&lt;/p&gt;

&lt;h3 id=&quot;termites&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8305&quot;&gt;Termites&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$N$개의 수 $A_1 \cdots A_N$가 있다. 두 명이 서로 번갈아가면서, $0$과 이웃한 수 $A_i \ne 0$를 골라, 자신의 점수에 더한 후, $A_i$의 값을 $0$으로 바꾼다. 각자 최선을 다할 때, 최종 점수를 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;여러 생각을 해봤는데, $O(N^2)$에도 못 풀겠다. 대충 찾아보니, &lt;a href=&quot;https://www.mimuw.edu.pl/~idziaszek/termity/termity.pdf&quot;&gt;논문&lt;/a&gt;이 나온다.&lt;/p&gt;

&lt;p&gt;세상에… 논문에서 “Fusion Principle” 이름만 보자마자 풀이를 알아버렸다. 알고 있는 테그닉인데 떠올리지 못한 점이 아쉽다.&lt;/p&gt;

&lt;p&gt;$N$개의 수가 있고, 서로 번갈아가면서 좌우의 수를 하나씩 뽑는 (단순한 버전의) 문제를 생각하자. 인접한 세 수 $a$, $b$, $c$에 대하여, $b = \max (a, b, c)$라면, 이 세 수를 하나의 수 $a + c - b$로 합칠 수 있다. 만일, 상대방이 $a$를 가져간다면, 나는 즉시 $b$를 가져가고, 상대방은 남은 $c$까지 가져가는 전략이 항상 최적이기 때문이다.&lt;/p&gt;

&lt;p&gt;이러한 Reduction을 계속 진행하면, 남은 수는 정렬되어있다. 이제, 가장 큰 수부터 차례대로 나누어 가지면, 그것이 답이 된다.&lt;/p&gt;

&lt;p&gt;원 문제에서는 한 쪽 끝이 막혀있을 수 있는데, 비슷하게 적당히 처리하면 된다. 전체 시간 복잡도는 $O(N \lg N)$.&lt;/p&gt;

&lt;h3 id=&quot;termites-2&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8319&quot;&gt;Termites 2&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;트리에서 논다…&lt;/p&gt;

&lt;h3 id=&quot;tighten-up&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/4967&quot;&gt;Tighten Up!&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;이차원 평면에 $N$개의 못이 박혀 있고, $N$-lines chain 형태의 실이 있다. 실의 양쪽 끝을 평면에 수직한 방향으로 잡아당겨, 실이 못에 적당히 걸쳐 팽팽해지도록 한다. 이때, 실의 길이를 구하는 문제이다.&lt;/p&gt;

&lt;p&gt;재미있는 기하 문제이다. 실의 상태를 못에 대한 상대적인 위치를 이용하여 나타내면 해결할 수 있다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="ICPC" /><category term="연습" /><summary type="html">장난감 경주</summary></entry><entry><title type="html">ICPC WF 연습 (2/1)</title><link href="http://localhost:4000/icpc/practice/2021/02/02/WF-practice/" rel="alternate" type="text/html" title="ICPC WF 연습 (2/1)" /><published>2021-02-02T10:17:40+09:00</published><updated>2021-02-02T10:17:40+09:00</updated><id>http://localhost:4000/icpc/practice/2021/02/02/WF-practice</id><content type="html" xml:base="http://localhost:4000/icpc/practice/2021/02/02/WF-practice/">&lt;h3 id=&quot;팀-연습-시작&quot;&gt;팀 연습 시작!&lt;/h3&gt;

&lt;p&gt;2021년 6월 이후에 열릴 ICPC World Final 2021에서 좋은 성과를 얻기 위해, 오늘부터 PS 연습을 하기로 팀원과 약속하였다.&lt;/p&gt;

&lt;p&gt;사실 우리 팀이 나가는 대회가 WF 2020인지 WF 2021인지 헷갈린다. WF 2020은 2021년 6월 19일 ~ 24일에 개최된다고 하니, 남은 이 긴 기간동안 팀 연습을 확실하게 많이 하면 좋겠다. (그런데, 군대는 언제 가지..?)&lt;/p&gt;

&lt;p&gt;오늘은 총 다섯 문제로 이루어진 problemset을 풀었다. 목표 시간은 3시간.&lt;/p&gt;

&lt;h3 id=&quot;morse-code&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9289&quot;&gt;Morse Code&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;모스 부호가 입력으로 주어지면, 각 부호를 알파벳으로 치환하는 문제.&lt;/p&gt;

&lt;p&gt;길이 26의 string array를 열심히 타이핑한 후, 5분만에 맞았다.&lt;/p&gt;

&lt;h3 id=&quot;computational-geometry&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8290&quot;&gt;Computational Geometry&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;정수 $N$가 주어지면, 꼭짓점의 개수가 $N$고 넓이가 $N$인 단순직교다각형을 출력하는 문제.&lt;/p&gt;

&lt;p&gt;자명하게, $N$은 4 이상의 짝수여야 한다. 우상단으로 지그재그 올라가는 계단 형태의 다각형을 생각하면, 4이상의 짝수 $N$에 대하여 항상 답이 존재함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;이 접근까지는 쉽게 왔는데, 꼭짓점의 좌표를 구하는 과정에서 조금 막혔다. 평소 코딩 연습을 안 한 잘못이라고 생각한다. 대충 짜고 제출하니 맞았다. 30분 AC.&lt;/p&gt;

&lt;p&gt;세빈이의 코드를 읽었는데, 아주 간결했다. 쉬운 문제에서는 세빈이의 코딩 스타일을 따라하기로 다짐했다.&lt;/p&gt;

&lt;h3 id=&quot;computational-biology&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8287&quot;&gt;Computational Biology&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;길이 $N$의 문자열 $S$가 주어지면, $S$의 Cyclic fragment이면서 길이가 $K$인 문자열의 Cyclic occurrence의 최댓값을 구하는 문제.&lt;/p&gt;

&lt;p&gt;세 시간 안에 풀지는 못했다. Cyclic 조건을 모두 무시하면, 문자열 $S$에 대하여 Sliding을 시도하면서, 모든 길이 $K$의 부분문자열의 Hash를 계산하면 쉽게 풀 수 있다. 이 접근을 Cyclic 조건이 있는 문제에 적용을 하자니, 어떤 부분문자열이 $S$의 Cyclic fragment인지 효율적으로 판별하는 방법을 알아내야 하는데, 찾지 못했다. Cyclic fragment 조건을 naive하게 확인하면 $O(NK)$가 된다고 생각하였고, Suffix array 등의 아이디어를 고민하다가 포기하였다.&lt;/p&gt;

&lt;p&gt;치킨을 먹고 업솔빙을 하면서 다시 풀어보니, Cyclic fragment 조건을 naive하게 확인해도 $O(N \lg N)$라는 사실을 깨달았다. 단지, 한 번 계산한 문자열은 다시 계산하지 않는다는 아이디어를 적용하면 된다.&lt;/p&gt;

&lt;p&gt;$O(N^2)$번의 문자열 비교를 해야 하기 때문에, $10^9$-scale의 소수 두 개를 이용하여 hash를 구현하였다. 시간 복잡도는 $O(N \lg N)$이며, unordered map/set을 사용하면 $O(N)$이다.&lt;/p&gt;

&lt;p&gt;“한 번 계산한 문자열은 다시 계산하지 않는다” 아이디어와, 문제 조건에서 “A cyclic fragment is a word such that &lt;strong&gt;ALL&lt;/strong&gt; its cyclic rotations are subwords”을 올바르게 구현하는데 사소한 실수가 있어서 두 번 틀렸다. 업솔빙을 할 때에도 침착할 필요가 있다.&lt;/p&gt;

&lt;p&gt;세빈이의 코드를 읽었고, 풀이는 완벽하게 동일하다고 생각한다. 근데, 소스 코드의 길이가 나의 절반인 점은 정말 놀라웠다.&lt;/p&gt;

&lt;p&gt;dotorya는 Suffix array를 이용해서 풀었다. 뭔가 이분 탐색을 열심히 하며, 시간 복잡도는 동일하게 $O(N \lg N)$가 나온다. 풀이 이해는 잘 안 된다. 한 번 생각해보기로 했다.&lt;/p&gt;

&lt;h3 id=&quot;cheese-if-you-please&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17854&quot;&gt;Cheese, If You Please&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Linear Programming 기초 문제.&lt;/p&gt;

&lt;p&gt;이론으로만 알고 있는 LP를, 실제 문제로 만나게 되어서 기뻤다.&lt;/p&gt;

&lt;p&gt;KAIST 더불어민규당 팀노트의 Dantzig’s simplex algorithm 구현을 가져와서 풀었다. 행렬의 행과 열을 헷갈려서 시간 지체가 조금 있었다. 60분 AC.&lt;/p&gt;

&lt;p&gt;우리 팀만의 팀노트를 만들어야 하는데… 언젠가 날 잡고 해야 겠다.&lt;/p&gt;

&lt;h3 id=&quot;colorful-doors&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19270&quot;&gt;Colorful Doors&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;일렬로 $N$쌍의 포탈을 배치한 다음, 항상 오른쪽으로 달리는 사람이 왼쪽 끝에서 시작하여 오른쪽 끝으로 빠져나간다. 이 사람이 방문한 모든 지점이 주어질 때, 이러한 방문 조건을 만족하는 포탈 배치를 구하는 문제.&lt;/p&gt;

&lt;p&gt;동일한 유형의 문제가 옛날 IOI에 있었기에, 사이클을 가지고 논다는 접근까지는 아주 빠르게 했다.&lt;/p&gt;

&lt;p&gt;$2N$개의 지점 각각에 두 개의 in/out 정점을 둔 후, $4N$개의 간선을 어떻게 배치해야 하는가? 라는 문제로 바꾸면 상당히 직관적으로 문제를 풀 수 있다.&lt;/p&gt;

&lt;p&gt;먼저, 입력이 전부 ‘1’인 경우, $N$가 짝수면 풀리고 홀수면 답이 존재하지 않는다. 사실, 홀수일 때 답이 없다는 것을 증명하지는 못했는데, 공식 풀이를 보니 대충 되는 것 같다.&lt;/p&gt;

&lt;p&gt;모든 Path의 길이의 합이 짝수여야만 답이 존재할 수 있다.&lt;/p&gt;

&lt;p&gt;단일 Path는 두 개의 포탈을 이용하여 항상 그 길이를 4씩 줄여나갈 수 있다. 이를 이용하여, 모든 Path의 길이를 3 이하로 만든다.&lt;/p&gt;

&lt;p&gt;두 개의 Path는 하나의 포탈을 이용하여, 각각의 길이를 1씩 줄일 수 있다. 따라서, 길이가 가장 긴 두 개의 Path를 잡고, 하나의 포탈을 이용하여 각각의 길이를 줄이는 과정을 계속 반복함으로써 문제를 해결할 수 있고, 이렇게 구현을 했더니 틀렸다.&lt;/p&gt;

&lt;p&gt;생각을 좀 해보니, 길이 3인 Path와 길이 1인 Path는 (2, 0)으로 reduct되는데, 이러면 답을 찾을 수 없게 된다. (3, 1)인 case에 대해 예외 처리를 해줬고, 그래도 틀렸다.&lt;/p&gt;

&lt;p&gt;더 생각을 해보니, (4, 2)가 있는데, length 4-reduction을 하면, (2, 0)가 되어 답을 찾을 수 없다. length 4-reduction을 길이가 4 이하가 될 때까지만 반복하는 것으로 수정했다.&lt;/p&gt;

&lt;p&gt;몇 개의 잔실수가 있었고, 전부 해결하니 맞았다.&lt;/p&gt;

&lt;p&gt;공식 풀이를 보니, 나보다 훨씬 간결하게 정해를 작성할 수 있는 것으로 보인다. 매번 느끼지만, 나는 풀이를 여과하는 작업을 안 한다. 이를 매번 생각하면서 연습을 해야겠다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="ICPC" /><category term="연습" /><summary type="html">팀 연습 시작!</summary></entry><entry><title type="html">2020 ICPC Seoul Regional 후기</title><link href="http://localhost:4000/contest/review/icpc/2020/11/14/2020-icpc-seoul-regional/" rel="alternate" type="text/html" title="2020 ICPC Seoul Regional 후기" /><published>2020-11-14T20:52:30+09:00</published><updated>2020-11-14T20:52:30+09:00</updated><id>http://localhost:4000/contest/review/icpc/2020/11/14/2020-icpc-seoul-regional</id><content type="html" xml:base="http://localhost:4000/contest/review/icpc/2020/11/14/2020-icpc-seoul-regional/">&lt;h3 id=&quot;icpc-seoul-인터넷-예선&quot;&gt;ICPC Seoul 인터넷 예선&lt;/h3&gt;

&lt;p&gt;나는 dlalswp25, sebinkim와 함께 “Let Us Win ICPC WF”라는 팀명으로 처음으로 ICPC에 참가하였다.&lt;/p&gt;

&lt;p&gt;인터넷 예선 때에는 8문제를 풀어 서울대학교 턱걸이로 본선에 진출하였다. 원래라면 10문제 이상 풀어야 함이 맞지만, 우리가 이렇게 말렸던 이유는 크게 세 가지라고 생각한다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;8문제만 풀어도 안정권으로 본선에 진출할 것이라고 착각하였으며, 실제로 어떠한 위기 의식도 느끼지 못했다.&lt;/li&gt;
  &lt;li&gt;dlalswp25가 크게 캐리한 반면, 나와 sebinkim은 크게 말렸다. sebinkim은 초반부터 2시간 가까이 A를 잡았고, 나는 풀이가 나온 B, G를 오랜 시간 코딩했지만 결국 맞지 못했다. sebinkim가 J의 $O((N+K) \lg^2 N)$ 풀이를 알아내고, 상당 시간 투자하여 구현을 했는데, TLE 판정을 받은 것 또한 아쉬웠다. 대회 말미에 dlalswp25가 A를 맞음으로써 8 solves로 마무리할 수 있었는데, 지금 돌이켜보면 상당히 아찔한 상황이 아닐까 싶다. ㅋㅋ;&lt;/li&gt;
  &lt;li&gt;팀원 모두가 대회 환경에 익숙치 않았다. 대회용 컴퓨터로 sebinkim의 Ubuntu 환경 노트북을 사용하였는데, 나와 dlalswp25는 단축키 등에 익숙하지 않아 자주 sebinkim을 불렀다. 신양학술정보관에서 시험을 친 지라 프린트를 할 수 있는 환경이었지만, 프린트 전용 충전 카드(?)를 미리 준비하지 않아, 노트북 화면을 반으로 나누어 한쪽은 코딩을 하고 한쪽은 문제를 띄우는 형식으로 대회를 치루었다. 결과적으로 코딩의 흐름도 끊기고 문제 이해에도 시간 지연이 발생하였다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;솔직히 말해서 팀원 셋 중 한 명만 대회에 참가하고, 나머지 둘은 옆에서 놀고만 있었어도 이보다 좋은 성적을 거두지 않았을까 생각한다. 많은 주변 사람들은 “윤교준 똑떨”을 기대했지만, 어찌어찌 붙어서 다행이다.&lt;/p&gt;

&lt;h3 id=&quot;prepare-the-contest&quot;&gt;Prepare the contest&lt;/h3&gt;
&lt;p&gt;인터넷 예선 결과를 보고 부족한 점이 정말 많음을 깨달았다. 팀원 세 명이 모두 Codeforces red coder으로, 개개인의 PS 역량만을 본다면 전혀 꿇릴게 없다고 나는 장담한다. 아마 우리 모두 ‘팀 연습의 부재’가 가장 큰 패인이라고 깨달은 듯 하다.&lt;/p&gt;

&lt;p&gt;팀원 세 명 모두 각자의 스케쥴에 치어 살아, 팀 연습은 커녕 개인 PS 연습할 시간도 부족하였다. 그럼에도 불구하고, 두 번의 팀 연습을 진행하면서, 이것저것 암묵의 룰을 만들었던 것 같다. 컴퓨터 독점하지 않기, 나보다 쉽고 빠른 구현이 가능한 문제를 잡은 사람에게 우선적으로 컴퓨터를 넘겨주기, 구현의 대략적인 틀을 완성하고 키보드를 잡기, 문제를 읽거나 풀이를 생각하거나 손코딩을 해보는 등 시간을 낭비하지 않기, …&lt;/p&gt;

&lt;h3 id=&quot;before-the-contest&quot;&gt;Before the contest&lt;/h3&gt;

&lt;p&gt;인터넷 예선처럼, 본선 대회도 신양학술정보관을 사용하려고 전날에 예약을 해두었다. 그런데, 당일 오전 10시 반에 dlalswp25와 함께 가보니, 왁스칠을 해서 예약한 방을 하루종일 사용할 수 없다는 청천벽력의 이야기를 들었다. 거의 멘붕의 상태로, 프린터가 되는 독립적인 공간을 찾고자 한 시간동안 노력했지만, 결국 바로 옆 공대 건물의 빈 강의실을 무단 점거해서 시험을 치뤘다. 이 과정에서 나는 1년치에 해당하는 운동을 했고, 많은 체력 소모가 있었다.&lt;/p&gt;

&lt;h3 id=&quot;timeline&quot;&gt;Timeline&lt;/h3&gt;

&lt;h4 id=&quot;0--4-min&quot;&gt;0 ~ 4 min.&lt;/h4&gt;

&lt;p&gt;대회 직전에 장소 소동이 있었던지라, 대회 환경 세팅을 아마도 꼴찌로 한 듯 싶다. 덕분에, 대회가 시작하고서 신원 검사와 책상 위 확인이 이루어졌다.&lt;/p&gt;

&lt;p&gt;sebinkim가 12문제의 Description pdf를 하나씩 다운받아 USB에 옮기는 작업을 하였다. 통합본 pdf가 없는 건지, 있는데 우리가 못 찾은 건지는 모르겠지만, 아무튼 초반의 꽤 긴 시간이 의미없게 흘러갔다.&lt;/p&gt;

&lt;h4 id=&quot;4--10-min&quot;&gt;4 ~ 10 min.&lt;/h4&gt;

&lt;p&gt;USB에 담긴 12개의 pdf를 인쇄하기 위해, 강의실에서 신양학술정보관 2층으로 뛰어가, 컴퓨터에 USB를 꽂고, 12개의 pdf를 하나하나 열어 Ctrl+P를 한 후, 용지 크기를 A4로 설정하여 인쇄를 시도하고, 복합기의 ‘작업 현황’에 들어간 다음, 다시 12개의 인쇄 작업을 모두 활성화해서, 문제를 모두 인쇄하였다.&lt;/p&gt;

&lt;p&gt;근데 망할 자리 비움은 3분만 가능한데, 강의실에서 신양학술정보관으로 전속력으로 뛰면 정확하게 왕복 2분이 걸린다. 그래서 강의실에서 뛰어가서, 인쇄 버튼 6개 누르고, 다시 강의실로 돌아와서 3분 체크하고, 다시 뛰어가서, 나머지 6개 인쇄하고, 다시 돌아오는 미친 짓을 했다.&lt;/p&gt;

&lt;h4 id=&quot;7-min&quot;&gt;7 min.&lt;/h4&gt;

&lt;p&gt;강의실에서 노트북으로 문제를 읽는 sebinkim과 dlalswp25는 각각 A, B가 쉬움을 깨닫고 이 문제를 잡았다.&lt;/p&gt;

&lt;p&gt;B는 실버 난이도의 주는 문제였고, dlalswp25가 코딩해서 맞았다.&lt;/p&gt;

&lt;h4 id=&quot;10--15-min&quot;&gt;10 ~ 15 min.&lt;/h4&gt;

&lt;p&gt;이미 체력 소모를 한 상태에서 4분 왕복 달리기를 한 나는, 체력 방전이 너무 심했다. dlalswp25가 출력물을 가지러 신양학술정보관으로 다녀올 동안, 나는 블랙 보리를 마시면서 헉헉대기만 했다. 이게 PS 대회인지 달리기 대회인지…&lt;/p&gt;

&lt;p&gt;문제 분배는 sebinkim가 ABCD, dlalswp25가 EFGH, 내가 IJKL을 잡도록 이루어졌다.&lt;/p&gt;

&lt;h4 id=&quot;23-min&quot;&gt;23 min.&lt;/h4&gt;

&lt;p&gt;I, J는 영어가 어려워 제대로 읽지 않았고, K는 레전드 타일링 문제, L은 문제가 상당히 단순한 수열 문제임을 알았다.&lt;/p&gt;

&lt;p&gt;sebinkim은 A를 코딩했지만, 예제가 나오지 않았고, 쉬운 문제 E를 푼 dlalswp25에게 바로 노트북을 넘겨주었다.&lt;/p&gt;

&lt;p&gt;dlalswp25는 E를 뚝딱 짜더니 한 번에 맞았다.&lt;/p&gt;

&lt;p&gt;E는 말을 쓸때없기 길게 늘여쓴 재미 없는 게임 문제인데, dlalswp25가 쉽다고 하지 않았다면, 나는 이게 쉬운 문제인 줄 몰랐을 듯 하다. dlalswp25가 이런 유형의 문제에 강하다는 것을 세삼 느꼈다.&lt;/p&gt;

&lt;h4 id=&quot;32-min&quot;&gt;32 min.&lt;/h4&gt;

&lt;p&gt;나는 문제를 풀고 있을 동안, sebinkim과 dlalswp25가 번갈아가면서 노트북을 잡았다.&lt;/p&gt;

&lt;p&gt;dlalswp25가 C를 맞았다고 해서 그냥 그런가보다 싶었는데, 10분만에 읽고 어케 짜서 맞았는지 모르겠다ㅋㅋ.&lt;/p&gt;

&lt;p&gt;C는 Description이 아주 더럽게 쓰여있는데, 두 아파트 단지 사이에 존재하는 모든 정점은 좋은 지역이라는 사실을 관찰하면 쉽게 풀 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;42-min&quot;&gt;42 min.&lt;/h4&gt;

&lt;p&gt;지금까지 문제를 제출하면서 스코어보드 염탐을 계속 하고 있었는데, 우리 팀은 1211789 팀의 꽁무니를 열심히 잘 쫒고 있었다.&lt;/p&gt;

&lt;p&gt;스코어보드에서 J가 풀렸다는 이야기를 듣고, 영어 때문에 포기했던 문제인 J를 다시 한 번 읽어보았다.&lt;/p&gt;

&lt;p&gt;문제에서 요구하는 것이 “Do you know RREF? I know Gaussian Elimination!”임을 깨닫고, 가우스 소거법을 뚝딱 짜서 맞았다.&lt;/p&gt;

&lt;p&gt;bitset을 썼기 때문에, 시간 복잡도는 $O \left( \frac{N^3}{64} \right)$며, 상당히 간결한 코딩을 할 수 있었다.&lt;/p&gt;

&lt;p&gt;대회에서 첫 코딩이었는데 말리지 않아서 기분이 좋았다.&lt;/p&gt;

&lt;h4 id=&quot;46-min&quot;&gt;46 min.&lt;/h4&gt;

&lt;p&gt;내가 코딩이 끝나자마자, sebinkim가 노트북을 잡고 G를 짰다.&lt;/p&gt;

&lt;p&gt;G는 Description이 상당히 마음에 들지 않게 적혀 있는데, 암튼 $X_i \pm d \times i$의 평균을 관찰하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;1-hour-중간-점검&quot;&gt;1 hour 중간 점검&lt;/h4&gt;

&lt;p&gt;대회 초반 한 시간동안 BCEGJ 다섯 문제를 풀었고, 놀랍게도 한 번도 틀리거나 말리지 않았다.&lt;/p&gt;

&lt;p&gt;당시 1등인 1211789 팀과 같은 수의 문제를 풀었는데, 패널티 차이가 조금씩 벌어지기 시작해서, ‘문제 수로 이겨야 한다’는 마인드로 앞으로의 시간을 임했다.&lt;/p&gt;

&lt;h4 id=&quot;70-min&quot;&gt;70 min.&lt;/h4&gt;

&lt;p&gt;우리는 ‘쉬운 문제는 전부 풀었다’라고 생각하는 시기었는데, rkm0959 팀이 H를 풀었다는 소식을 들었다.&lt;/p&gt;

&lt;p&gt;sebinkim과 dlalswp25는 H를 읽다가 기하 같아서 뒤로 미루어 두었다길래, 내가 읽었고, 수열 $A$, $B$, $C$가 주어질 때, $A_i - 2 B_j + C_k = 0$을 만족하는 세 순서쌍 $(i, j, k)$의 개수를 찾는 문제임을 깨달았다.&lt;/p&gt;

&lt;p&gt;각 수의 범위가 상당히 작다는 사실을 보고, FFT 기초 문제라는 것을 알았다. 팀노트에 적힌 코드를 이용해서, $O(N + X \log X)$에 해결하였다.&lt;/p&gt;

&lt;h4 id=&quot;88-min&quot;&gt;88 min.&lt;/h4&gt;

&lt;p&gt;sebinkim가 한 번의 WA를 받고, 뚝딱뚝딱 하더니 결국 고쳐서 A를 맞았다.&lt;/p&gt;

&lt;p&gt;A는 500개의 수직/수평 선분이 주어질 때, 문제에서 하라는 것을 짜면 되는 구현 문제이다. 다만, 상당히 할 게 많고 실수할 요소 또한 많다고 생각한다.&lt;/p&gt;

&lt;h4 id=&quot;98-min&quot;&gt;98 min.&lt;/h4&gt;

&lt;p&gt;나는 L을 읽고, ICPC WF 2017 D “Money for Nothing”임을 깨달았지만, 분할 정복을 통한 $O(N \lg^2 N)$ 풀이밖에 관찰하지 못하였다. 아무리 생각해도 더 좋은 접근을 찾을 수 없어, dlalswp25한테 넘겼었다.&lt;/p&gt;

&lt;p&gt;나는 수열을 2~3개의 구간으로 나눌 생각을 했던 반면에, dlalswp25는 수열의 최댓값에 집중하였다. 답은 항상 수열의 최댓값을 한쪽 끝으로 갖거나, 최댓값을 기준으로 좌우로 분포함을 관찰하였고, 여기에 “Money for Nothing” 풀이를 적용해서 $O(N \lg N)$ 풀이를 얻었다.&lt;/p&gt;

&lt;p&gt;바로 코딩에 들어가서 뚝딱 짜고 냈는데, WA가 나와서 살짝 흔들렸었다. 88 ~ 98 min. 때, Naïve 풀이와 DM을 짜서 돌려보았고, 운 좋게 반례를 얻을 수 있었다.&lt;/p&gt;

&lt;p&gt;Divide &amp;amp; Conqure 과정에서 인덱싱이 잘못 되어있음을 알아냈고, 고쳐서 맞았다. 하면 안되는 실수를 해서 속상했다.&lt;/p&gt;

&lt;h4 id=&quot;100-min-중간-점검&quot;&gt;100 min. 중간 점검&lt;/h4&gt;

&lt;p&gt;이제 정말로, 쉬운 문제는 전부 해치웠다고 생각했다. 이때 우리는 ABCEGHJL, 8문제를 해결했고, 당시 1등이었다.&lt;/p&gt;

&lt;p&gt;2등인 1211789 팀은 7문제를 풀어, 우리가 한 문제 앞서 나가고 있었고, I 빼고 남들이 푼 문제는 전부 풀은 상태였다.&lt;/p&gt;

&lt;p&gt;I는 내가 잡았던 문제로, 열심히 고민했지만 $O((N^2 + M) \lg N)$ 풀이는 발견하지 못했고, 그렇다고 $O((N^2 + M) \lg^2 N)$을 구현하기에는 TLE를 받을 거 같았다.&lt;/p&gt;

&lt;p&gt;내가 H, L을 코딩할 동안, sebinkim과 dlalswp25가 열심히 토론하더니, 2D Fenwick $O((N^2 + M) \lg^2 N)$ 풀이를 발견하였다. 자료구조가 Fenwick으로 상당히 가벼운 점은 좋았으나, ‘이게 정말 맞을까?’와 ‘이게 정말 의도된 풀이일까?’라는 생각 때문에, 바로 구현할 용기가 나지 않았다.&lt;/p&gt;

&lt;p&gt;적당한 논의 끝에, sebinkim가 I를 한 번 짜보기로 하고, 나와 dlalswp25는 남은 DFK를 의논하기 시작하였다.&lt;/p&gt;

&lt;h4 id=&quot;117-min&quot;&gt;117 min.&lt;/h4&gt;

&lt;p&gt;I 구현을 마친 sebinkim가, “나 구현 다했어. 이거 내볼까?” 하길래, “맞으면 장땡이다, 한 번 내봐 ㄱㄱ”했다.&lt;/p&gt;

&lt;p&gt;기대 반, 의심 반으로 제출 결과를 기다렸는데, 어머나, 맞아버렸다.&lt;/p&gt;

&lt;p&gt;sebinkim가 I를 맞아버려, 1등과 2등의 차이는 두 문제로 벌어졌고, 아마 이 때부터 승기가 우리 팀으로 넘어오지 않았나 싶다.&lt;/p&gt;

&lt;p&gt;나중에 I 코드를 분석해보니, Fenwick의 수행 시간은 인덱스의 켜져 있는 bit 수에 비례한다는 이상한 성질이 잘 적용되어, 전체 시간 복잡도가 $O\left( \frac{ N^2 \lg^2 N }{8} + M \lg^2 N \right)$로 나왔다. 아ㅋㅋ 이거는 인정이지ㅋㅋ.&lt;/p&gt;

&lt;h4 id=&quot;2-hours-마지막-점검&quot;&gt;2 hours 마지막 점검&lt;/h4&gt;

&lt;p&gt;대회는 세 시간이 남았고, 문제도 세 개가 남았다. 각자 한 문제씩 맡아서 한 시간씩 코딩해서 해결하자는 전략을 내세웠다.&lt;/p&gt;

&lt;p&gt;DF는 문제 조건이 아주 복잡해서, 영어를 못하는 내가 이해하기에는 너무 어려웠다. 결국, 나는 K를, sebinkim과 dlalswp25는 DF를 맡았다.&lt;/p&gt;

&lt;h4 id=&quot;150-min&quot;&gt;150 min.&lt;/h4&gt;

&lt;p&gt;많은 어려움이 있었지만, dlalswp25가 DF를 읽어, 팀원 모두에게 문제 내용을 인지시켰다.&lt;/p&gt;

&lt;p&gt;나는 K에서 두께가 1이 아닌 부분을 뭉친 후, Tree 형태로 생각해서 Bottom-up으로 해결하면 됨을 관찰하였고, dlalswp25와 논의하면서 풀이를 다듬었다. 논의 끝에, 구현은 상당히 거지같지만 풀이가 정당하다는 확신을 얻었고, 바로 K 구현에 착수하였다.&lt;/p&gt;

&lt;p&gt;K가 풀린다는 소식을 널리 알리고, sebinkim과 dlalswp25가 DF에만 집중할 수 있도록 하였다.&lt;/p&gt;

&lt;h4 id=&quot;190-min&quot;&gt;190 min.&lt;/h4&gt;

&lt;p&gt;25분만에 더러운 K 구현을 마치고, 손수 만든 $16 \times 16$ 격자판 입력을 넣었는데, 답이 나오지 않음을 알아차렸다.&lt;/p&gt;

&lt;p&gt;다행히, assert문을 잔뜩 집어넣어, 디버깅에는 큰 어려움이 없었다. 하지만, K 풀이가 원래 생각했던만큼 단순하지 않다는 것은 확실하게 알 수 있었다.&lt;/p&gt;

&lt;p&gt;조금 더 생각한 후, 풀이의 전체적인 틀을 뜯어 고칠 필요는 없음을 알았다. 코드의 예쁨을 포기하고, 예외 처리 구문을 덕지덕지 붙여나갔고, 모든 예외에 대해 해결하고 나니 6000 bytes의 구데기 결과물을 볼 수 있었다.&lt;/p&gt;

&lt;p&gt;sebinkim과 dlalswp25에게 K 코딩을 마쳤음을 알리고, 적당한 입력 데이터를 요구하였다. sebinkim가 제안한 입력을 넣었고, 답이 올바름을 확신했다.&lt;/p&gt;

&lt;p&gt;K를 제출하고 AC를 받았다. 틀렸다면 엄청난 디버깅 지옥에 빠질 수도 있었던 순간이었는데, 정말 짜릿하고 행복하였다. 덕분에, 바지에 지리지 않고 교양 있게 화장실을 다녀올 수 있었다.&lt;/p&gt;

&lt;h4 id=&quot;206-min&quot;&gt;206 min.&lt;/h4&gt;

&lt;p&gt;이제 DF가 남았다. K를 구현하면서 둘의 대화를 전부 엿듣고 있었기 때문에, 합류할 때 큰 어려움은 없었다.&lt;/p&gt;

&lt;p&gt;나는 제대로 이해도 못한 F를 sebinkim가 Dominator Tree를 쓰면 풀린다고 주장하였고, 이에 dlalswp25도 수긍하는 분위기 같아서, F는 개입하지 않았다.&lt;/p&gt;

&lt;p&gt;sebinkim에게 노트북을 바로 넘겨주었고, 나는 지금까지 나온 D의 접근을 다시 한 번 검증하였다.&lt;/p&gt;

&lt;p&gt;팀노트를 보고 뚝딱뚝딱 하더니, sebinkim가 F를 제출해서 맞았다. sebinkim은 자신이 한 것은 랩노트를 베낀 것 뿐이다라고 주장하지만, 나는 F를 읽고 Dominator가 떠오른 sebinkim가 참 대단하게 느껴졌다. 대회가 끝나고 다른 팀의 이야기를 들어보니, F에서 SCC로 말렸다는 이야기가 꽤 나왔다. 난 아직도 F를 읽고 Dominator와 연관이 있음을 떠올리지 못하겠다. ㅋㅋ;&lt;/p&gt;

&lt;h4 id=&quot;239-min&quot;&gt;239 min.&lt;/h4&gt;

&lt;p&gt;이제 D만 남았다! 심장이 쿵쾅쿵쾅 뛴다. 평소에도 하지 못한 올솔브를 ICPC Seoul Regional에서 할 수 있다는 점이 믿기지 않았다.&lt;/p&gt;

&lt;p&gt;sebinkim가 F 구현을 할 동안, dlalswp25와 논의를 하면서, 결국 $O(N^2 ( \Delta + \lg N))$ 즈음에 동작하는 풀이를 얻었다.&lt;/p&gt;

&lt;p&gt;나라면, 아무 생각 없이 2D Segment Tree를 짜서 뚝딱 돌리는 이 풀이를 짰겠지만, sebinkim가 굳이 그럴 필요까지는 없다면서, 풀이를 개선하였다.&lt;/p&gt;

&lt;p&gt;마지막 문제인 D를 sebinkim가 구현하기 시작했으며, 구경과 떠드는 것 밖에 할 게 없는 나와 dlalswp25는 D의 입출력을 만들었다.&lt;/p&gt;

&lt;p&gt;sebinkim은 뚝딱 잘 짰고, 예제와 만든 입력을 넣어, 올바른 답이 나옴을 확인하였다. 제출해서 WA를 받았지만, 단순한 실수를 저지름을 바로 깨달았고, 고쳐서 AC! 이렇게 우리는 12문제를 4시간만에 전부 풀어버렸다.&lt;/p&gt;

&lt;p&gt;D는 재미있는 아이디어가 몇 가지 요구되며, 약간의 전처리가 필요할 뿐, 어려운 구현 테크닉이 요구되지는 않는다. 그러나, 아이디어 자체를 떠올리는 과정이 살짝 까다롭다는 점과, D에서 요구하는 엄청나게 많은 요구사항이, 많은 팀이 D를 포기하게 만들지 않았을까 생각한다.&lt;/p&gt;

&lt;h4 id=&quot;after-240-min&quot;&gt;After 240 min.&lt;/h4&gt;

&lt;p&gt;일단 환호성을 엄청 질렀다. 솔직히, 저 상황에서 웃음꽃이 만개하지 않으면 감정이 매마른 사람일 것이다.&lt;/p&gt;

&lt;p&gt;우리가 K를 맞은 직후, 스코어보드가 Freeze 되었다. 스코어보드의 정보를 바탕으로, 우리와 다른 팀의 패널티를 계산하였고, Disqualify되지 않는 이상 1등임을 확신하였다.&lt;/p&gt;

&lt;p&gt;한 시간 동안, 무얼 했느냐 하면… 그냥 문제와 대회에 대해서 떠들었다. 모든 문제의 내용과 풀이를 공유하였고, 반성과 칭찬의 시간을 가졌고, WF 준비는 어떻게 할 것인가 등등…&lt;/p&gt;

&lt;p&gt;WF에 나가게 된 덕분에, 팀명에 대한 걱정이 배로 늘어났다ㅋㅋ. 이거 팀명 바꿀 수는 없는 건가..?&lt;/p&gt;

&lt;h4 id=&quot;after-the-contest&quot;&gt;After the contest&lt;/h4&gt;

&lt;p&gt;우리는 1등임을 확신할 수 있기에, 자축의 의미로 바로 소고기를 먹으러 갔다.&lt;/p&gt;

&lt;p&gt;고기집에서 스코어보드 공개를 지켜보면서 먹는 소고기는 정말 맛있다.&lt;/p&gt;

&lt;p&gt;팀원 sebinkim과 dlalswp25, 오늘 대회 정말로 수고했고, 아주 좋은 퍼포먼스를 보여주어 고맙다.&lt;/p&gt;

&lt;p&gt;내년에도 이 구성으로 한 번 더 ICPC에 나갈 수 있음 좋겠다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="대회" /><category term="풀이" /><category term="ICPC" /><category term="후기" /><summary type="html">ICPC Seoul 인터넷 예선</summary></entry><entry><title type="html">나는코더다 2019 송년대회 이야기</title><link href="http://localhost:4000/contest/review/2020/02/16/iamcoder-2019-yearend-contest/" rel="alternate" type="text/html" title="나는코더다 2019 송년대회 이야기" /><published>2020-02-16T02:03:27+09:00</published><updated>2020-02-16T02:03:27+09:00</updated><id>http://localhost:4000/contest/review/2020/02/16/iamcoder-2019-yearend-contest</id><content type="html" xml:base="http://localhost:4000/contest/review/2020/02/16/iamcoder-2019-yearend-contest/">&lt;h2 id=&quot;머릿말&quot;&gt;머릿말&lt;/h2&gt;

&lt;p&gt;2019년 12월 12일과 14일에 진행되었던 나는코더다 2019 송년대회(&lt;a href=&quot;https://www.acmicpc.net/contest/view/493&quot;&gt;교내&lt;/a&gt; / &lt;a href=&quot;https://www.acmicpc.net/contest/view/494&quot;&gt;Open&lt;/a&gt;)에 관하여, 이제나마 글을 적는다.&lt;/p&gt;

&lt;p&gt;그 당시 나는 대회가 끝나자마자 이 글을 올리고 싶었는데, 개인 블로그가 없었는지라… 많이 늦었지만, 최대한 기억을 되살려서 글을 몇 자 적어본다.&lt;/p&gt;

&lt;p&gt;2019년이 되자마자 나는 ‘나는코더다 기장으로서 대회를 열어야 한다’는 생각을 가지고 있었다. 연초부터 세빈이를 나와 함께 할 출제위원 자리로 앉혀놓고, 대회 문제를 준비하였다. 거의 1년 가까이 문제 아이디어를 모아두었기 때문에, 출제에 있어서 큰 어려움은 없었던 것 같다.&lt;/p&gt;

&lt;p&gt;대회 문제는 나와 세빈이가 전부 만들었지만, 대회를 운영함에 있어 그 나머지 부분은 여섯 분의 훌륭한 외부검수진이 빈틈없이 채워주셨다. (사전순으로) &lt;a href=&quot;https://www.acmicpc.net/user/cubelover&quot;&gt;cubelover&lt;/a&gt;, &lt;a href=&quot;https://www.acmicpc.net/user/imeimi2000&quot;&gt;imeimi2000&lt;/a&gt;, &lt;a href=&quot;https://www.acmicpc.net/user/jwvg0425&quot;&gt;jwvg0425&lt;/a&gt;, &lt;a href=&quot;https://www.acmicpc.net/user/koosaga&quot;&gt;koosaga&lt;/a&gt;, &lt;a href=&quot;https://www.acmicpc.net/user/rkm0959&quot;&gt;rkm0959&lt;/a&gt;, &lt;a href=&quot;https://www.acmicpc.net/user/TAMREF&quot;&gt;TAMREF&lt;/a&gt;. 모두 귀중한 시간을 내주시며, 문제의 퀄리티를 크게 높여주심과 동시에, 대회 전반에 있어 값진 피드백을 아낌없이 주셨다. 이 분들에게 다시 한 번 감사의 말씀을 드린다.&lt;/p&gt;

&lt;p&gt;또한, 송년대회가 더욱 즐거운 대회가 될 수 있도록 상품과 간식 등을 아낌없이 지원해주신 &lt;a href=&quot;https://www.nexon.com/&quot;&gt;NEXON&lt;/a&gt;과 관계자 분들께도 깊은 감사의 말씀을 드린다.&lt;/p&gt;

&lt;h2 id=&quot;대회-개요&quot;&gt;대회 개요&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;문제 이름&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;출제자&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;First Solve (교내)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;First Solve (Open)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;평면 분할&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;지학 전공 (김수민, 신재훈) - 4분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;N/A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;라면 사기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;킹장배빵빵 (황인성, 김도영B, 이도훈) - 80분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;august14 - 11분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;분할하기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;대가리 큰 곰돌이 푸를 사냥하는 명 윅은 노래를 부르다가 특별상만을 노린다. (성재용, 신명진, 조강현) - 26분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ainta - 15분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다오의 데이트&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1111 (박준호) - 38분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;povwhm - 27분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;참 어려운 문제&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HLD조아 (정희승, 임성재, 최승민) - 192분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;cki86201 - 29분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;촛불과 그림자&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;No Solve&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;No Solve&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;피아노 연주&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;김세빈&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;뚝심햄구이 (이종영, 안지민, 최은수) - 214분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;tlwpdus - 22분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;보고 정렬&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;김세빈&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;🇰🇷815🇰🇷 (고동현, 이민제, 이강민) - 19분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kcm1700 - 29분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비행기 타고 가요&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;뚝심햄구이 (이종영, 안지민, 최은수) - 23분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ainta - 78분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Bad Hair Day와 기댓값&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;김세빈&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;뚝심햄구이 (이종영, 안지민, 최은수) - 136분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ainta - 159분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정점 찾기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;🇰🇷815🇰🇷 (고동현, 이민제, 이강민) - 185분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;august14 - 99분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정기 모임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;김세빈&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;뚝심햄구이 (이종영, 안지민, 최은수) - 195분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;onjo0127 - 158분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;분수 계산&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;윤교준&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;의문부호의 꼭두각시 (김석표, 이민규, 이민준) - 172분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ainta - 90분&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;“평면 분할” 문제는 교내 대회에만 출제되었다. 놀랍게도 교내와 Open 모두에서 “촛불과 그림자”를 제외한 모든 문제가 풀렸다.&lt;/p&gt;

&lt;p&gt;여담이지만, “촛불과 그림자”를 제외한 모든 문제의 출제자 정해 코드는 아주 짧다. (“촛불과 그림자” 제외) 평균 C++ 코드 길이는 700 bytes밖에 되지 않는다. 대회 문제의 퀄리티와 풀이의 깔끔함을 강조하고 싶다.&lt;/p&gt;

&lt;p&gt;세빈이가 모든 문제의 풀이를 아주 깔끔하게 정리해주었다. &lt;a href=&quot;/downloadable_files/iamcoder_2019_yearend_solution.pdf&quot; download=&quot;download&quot;&gt;[세빈이의 풀이 슬라이드]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;대회-문제&quot;&gt;대회 문제&lt;/h2&gt;

&lt;h3 id=&quot;평면-분할&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18187&quot;&gt;평면 분할&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;개요&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 윤교준 / 데이터 제작자 : 윤교준&lt;br /&gt;운영진의 최단 코드 : 200 bytes (C++), 49 bytes (Python)&lt;br /&gt;교내 First Solver : 지학 전공 (김수민, 신재훈) - 4분&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이차원 평면에 기울기가 $-1$, $0$, $1$인 직선을 최대 $N$개 그릴 수 있다.&lt;br /&gt;직선에 의해 분할되는 영역의 개수의 최댓값을 구하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모든 참가자가 풀 수 있는 문제를 하나는 내야겠다고 생각해서 만들었다. 난도가 아주 낮기 때문에 Open에는 출제하지 않았다.&lt;/p&gt;

&lt;p&gt;교내의 잘하는 팀은 문제를 읽자마자 바로 풀지 않을까 생각했지만, 실제로는 First Solve가 의외의 팀이 대회 시작 후 4분에 푼 것이라 당황스러웠다.&lt;/p&gt;

&lt;p&gt;정답률은 84%로 최대고, 참가한 모든 팀이 풀어서 ‘맞았습니다’를 받았다. 다만, $\frac{N(N+1)}{2} + 1$를 출력하는 오답 코드가 많아서 아쉽다.&lt;/p&gt;

&lt;h4 id=&quot;풀이&quot;&gt;풀이&lt;/h4&gt;

&lt;p&gt;한 점에서 만나는 세 직선이 있다면 이들 중 하나를 살짝 평행이동함으로써, 세 직선이 한 점에서 만나지 않도록 함과 동시에 답을 더 크게 만들 수 있다. 고로, 해의 어느 세 직선도 한 점에서 만나지 않는다.&lt;/p&gt;

&lt;p&gt;기울기가 $-1$, $0$, $1$인 직선을 각각 $a$, $b$, $c$개 그린다고 하자. 그러면 분할되는 영역의 수는 $(a+1)(b+1)(c+1) - abc$다.&lt;/p&gt;

&lt;p&gt;$a+b+c \le N$를 만족하는 모든 $(a, b, c)$ 쌍에 대하여 영역의 수를 구해, 그 최댓값을 출력하면 된다.&lt;/p&gt;

&lt;p&gt;더 고민해보면, 답은 항상 $\left\lfloor{\frac{N^2}{3}}\right\rfloor + N + 1$임을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;라면-사기-small--large&quot;&gt;라면 사기 (&lt;a href=&quot;https://www.acmicpc.net/problem/18185&quot;&gt;Small&lt;/a&gt; / &lt;a href=&quot;https://www.acmicpc.net/problem/18186&quot;&gt;Large&lt;/a&gt;)&lt;/h3&gt;

&lt;h4 id=&quot;개요-1&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 윤교준 / 데이터 제작자 : TAMREF, 윤교준&lt;br /&gt;운영진의 최단 코드 : [Small] 479 bytes (C++) / [Large] 496 bytes (C++)&lt;br /&gt;교내 First Solver : 킹장배빵빵 (황인성, 김도영B, 이도훈) - 80분&lt;br /&gt;Open First Solver : august14 - 11분&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$N$개의 라면 공장이 있다. 각 공장에서 정해진 수량의 라면을 사고자 한다.&lt;br /&gt;연속한 1개, 2개, 3개의 공장에서 라면을 하나씩 구매하는 비용이 각각 $B$, $B+C$, $B+2C$다.&lt;br /&gt;최소 비용으로 구매할 때, 그 금액을 구하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;IZhO 2011의 &lt;a href=&quot;https://www.acmicpc.net/problem/11835&quot;&gt;Skyline 문제&lt;/a&gt;에서 제한을 크게 한 문제다. 교내 대회에는 $N \le 10^4$, $A_i \le 10^4$, $B = 3$, $C = 2$라는 추가적인 조건을 넣어서 Small 버전으로 출제하였다. 그렇기에 Small 버전으로 문제를 접한 교내 팀은 옳바른 풀이를 찾는 것이 Large 버전보다 더 어려웠을 것이라 생각한다. 동적계획법 풀이는 시간복잡도가 $O(N^3)$로 느리고, 그렇다고 $O(N^2)$ 혹은 $O(NX)$에 동작하는 올바른 풀이는 찾기 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;정해는 놀랍게도 선형에 풀린다. 모두가 Greedy 문제임을 알지만, 올바르게 접근하기 어려움은 사실이다. 교내와 Open 모두에서 정답률이 17%임이 이를 말해준다. Scoreboard가 비공개였다면 모두가 한 번씩은 제출하고 틀리지 않았을까 생각한다.&lt;/p&gt;

&lt;p&gt;개인적으로 내가 만든 가장 아름다운 문제라고 생각한다. 짧은 Description, 깔끔한 소스코드, 그러나 어려운 Greedy 풀이. 덤으로, Open에서 4위를 한 ainta가 이 문제를 풀었다면 3위를 차지하여 상품을 얻을 수 있었다. 어떻게 보면 이 문제가 상품 수상권을 갈랐다고도 말할 수 있을 것이다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-1&quot;&gt;풀이&lt;/h4&gt;

&lt;p&gt;만약 $B &amp;lt; C$라면, $C := B$라고 가정해도 답이 변하지 않는다. 이제, $C \le B$가 성립한다.&lt;/p&gt;

&lt;p&gt;$1$번 공장부터 $i$번 공장까지 최소 비용으로 라면을 구매하는 해를 이용하여, $i+1$번 공장까지 구매하는 최적해를 구하는 방법을 서술할 것이다.&lt;br /&gt;아래의 세 과정을 순서대로 시행하되, 각각의 과정을 최대한 많이 시행한다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;“$i$번 공장에서 비용 $B$로 라면 구매”를 “$i$번과 $i+1$번 공장에서 비용 $B+C$로 라면 구매”로 변경.&lt;/li&gt;
  &lt;li&gt;“$i-1$번과 $i$번 공장에서 비용 $B+C$로 라면 구매”를 “$i-1$번, $i$번, $i+1$번 공장에서 비용 $B+2C$로 라면 구매”로 변경.&lt;/li&gt;
  &lt;li&gt;$i+1$번 공장에서 비용 $B$로 라면 구매.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;정당성 증명은 꽤 단순하다. 각 라면마다 B, C, D 중 하나의 알파벳을 적는다고 하자. 각 알파벳의 의미를 설명하자면:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“B를 적는 것”은 “그 라면을 비용 $B$로 구매함”을&lt;/li&gt;
  &lt;li&gt;“C를 적는 것”은 “이전의 B가 적힌 라면과 엮어, 라면을 비용 $C$로 구매함”을&lt;/li&gt;
  &lt;li&gt;“D를 적는 것”은 “두 공장 전의 B가 적힌 라면과, 이전의 C가 적힌 라면과 엮어, 라면을 비용 $C$로 구매함”을 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 구매 비용은 $B \times (\text{B가 적힌 라면의 개수}) + C \times (\text{C나 D가 적힌 라면의 개수})$이므로, B를 최대한 적게 적는 것이 목표다.&lt;/p&gt;

&lt;p&gt;이제 위에서 서술한 과정의 의미를 파악해보자. 각 과정의 의미는 다음과 같다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$i$번 공장의 “B가 적힌 라면”을 최대한 많이 이용하여, $i+1$번 공장의 라면에 C를 적는다.&lt;/li&gt;
  &lt;li&gt;$i$번 공장의 “C가 적힌 라면”을 최대한 많이 이용하여, $i+1$번 공장의 라면에 D를 적는다.&lt;/li&gt;
  &lt;li&gt;남은 $i+1$번 공장의 라면에 B를 적는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;만일, 위와 같은 과정으로 만들어지지 않은 해가 있다면, 그 해에서 B를 C로 고치거나, C를 D로 고치는 작업을 항상 한 번 이상 할 수 있다. 따라서, 제시한 Greedy 풀이는 정당하다.&lt;/p&gt;

&lt;h3 id=&quot;분할하기&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18184&quot;&gt;분할하기&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;개요-2&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 윤교준 / 데이터 제작자 : 윤교준&lt;br /&gt;운영진의 최단 코드 : 239 bytes (C++)&lt;br /&gt;교내 First Solver : 대가리 큰 곰돌이 푸를 사냥하는 명 윅은 노래를 부르다가 특별상만을 노린다. (성재용, 신명진, 조강현) - 26분&lt;br /&gt;Open First Solver : ainta - 15분&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 집합이 Bitwise-or 연산에 대하여 닫혀있다면, 그 집합을 “좋은 집합”이라고 하자.&lt;br /&gt;전체집합 $U = { 0, 1, \cdots, 2^N - 1 }$의 부분집합 $A$에 대하여, $\left|A\right| = K$고, $A$와 $U \setminus A$가 모두 좋은 집합이면, $A$를 “$N, K$-분할”이라고 하자.&lt;br /&gt;$N$과 $K$가 주어질 때, “$N, K$-분할”의 존재성을 밝히고, 만일 존재한다면 그 예를 아무거나 하나 출력하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아이디어가 있어야 풀 수 있는 문제를 만들어보았다. 이 문제를 푸는 데, 출제한 나는 며칠이 걸렸고, 검수진 몇몇은 반나절 이상 걸리길래, 나는 문제의 난도가 높다고 생각했다. 교내 대회에서 18팀 중 절반 이상이 못 풀지 않을까 예상했는데, 실제로는 26분만에 First Solve가 나오고, 총 18팀 중 13팀이나 풀어서 굉장히 놀라웠다.&lt;/p&gt;

&lt;p&gt;다양한 풀이가 있을 것이라고 생각하고 출제를 했는데, 대부분의 참가자 풀이가 의도된 풀이와 유사하였다. Special Judge는 Or-convolution을 이용하여 $O(2^N N)$에 구현할 수 있으나, &lt;del&gt;내가 귀찮아서&lt;/del&gt; 구현의 정확도가 우선이라고 생각해서 $O(2^{2N})$로 naive하게 구현하였다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-2&quot;&gt;풀이&lt;/h4&gt;

&lt;p&gt;$N,K$-분할은 항상 존재하며, 이러한 집합을 만드는 방법은 단순하다.&lt;/p&gt;

&lt;p&gt;다음 $N+1$개의 집합을 생각하자:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\{ 0 \}, \{ 1 \}, \{ 2, 3 \}, \{ 4, 5, 6, 7 \}, \cdots, \{ 2^i, 2^i + 1, \cdots, 2^{i+1} - 1\}, \cdots, \{ 2^{N-1}, 2^{N-1}+1, \cdots, 2^N - 1 \}&lt;/script&gt;

&lt;p&gt;이제 우리는 다음 두 가지 성질을 관찰할 수 있다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 집합의 크기는 $1, 1, 2, 4, \cdots, 2^i, \cdots, 2^{N-1}$다.&lt;/li&gt;
  &lt;li&gt;$N+1$개의 집합 중 몇 개를 골랐을 때, 이들의 합집합과 그의 여집합은 항상 좋은 집합이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;고로, 우리는 모든 $N,K$-분할을 만들 수 있다. $1 \le K &amp;lt; 2^N$라면, 최상위 비트가 $K$에 포함된 수의 집합이 곧 $N,K$-분할이 된다.&lt;/p&gt;

&lt;h3 id=&quot;다오의-데이트&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18188&quot;&gt;다오의 데이트&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;개요-3&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 윤교준 / 데이터 제작자 : 윤교준&lt;br /&gt;운영진의 최단 코드 : 870 bytes (C++)&lt;br /&gt;교내 First Solver : 1111 (박준호) - 38분&lt;br /&gt;Open First Solver : povwhm - 27분&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이차원 격자판 위에 다오와 디지니가 서 있다.&lt;br /&gt;다오는 최대 $N$번 움직일 수 있으며, 각 움직임마다 두 방향 중 한 쪽으로만 이동할 수 있다.&lt;br /&gt;다오와 디지니가 만날 수 있는지 판별하고, 만일 가능하다면 그 방법을 구하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;올해 나는코더다 송년대회는 처음으로 외부 기업으로부터 후원을 받았다. NEXON 사회공헌팀에 직접 후원 관련 연락을 드렸고, NEXON 분들께서 흔쾌히 허락해주셔서 정말 기뻤다. 출제·검수 비용과 교내 대회장에 비치할 다과·음료 구매비, 참가자 간식 비용, 우승 상품 등을 모두 지원해주셨다. 학생 대회에 굉장히 큰 후원을 해주셨음에도 불구하고, NEXON은 그 어떤 후원 조건도 제시하지 않으셔서, 감사함을 표현하고자 이 문제를 만들었다.&lt;/p&gt;

&lt;p&gt;문제 컨셉은 크레이지 파크에서 가져왔다. 문제를 제작하면서 크레이지 파크를 찾아봤는데 어느새인가 서비스를 종료했더라…. 좌우지간, 후원기업 NEXON에 내가 바치는 문제였기에, 문제 구성과 난이도, 데이터 모두에 신경을 아주 많이 썼다.&lt;/p&gt;

&lt;p&gt;쓰다보니 생각이 났는데, 문제의 아이디어는 정종광 선생님께서 제공해주셨다. 출제에 도움을 주신 것에 대하여 정종광 선생님께 고마운 마음을 전해드리고 싶다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-3&quot;&gt;풀이&lt;/h4&gt;

&lt;p&gt;다오가 움직일 수 있는 방법은 총 $O(2^N)$가지다. $N \le 20$으로 굉장히 작기 때문에, 모든 경우를 전부 시도해도 괜찮다.&lt;/p&gt;

&lt;p&gt;의외로, 정답률은 교내 22%, Open 40%로 낮은데, 이는 내가 문제 설명을 깔끔하게 쓰지 못했기 때문이라고 생각한다.&lt;/p&gt;

&lt;h3 id=&quot;참-어려운-문제&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18189&quot;&gt;참 어려운 문제&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;개요-4&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 윤교준 / 데이터 제작자 : 김세빈&lt;br /&gt;운영진의 최단 코드 : 816 bytes (C++)&lt;br /&gt;교내 First Solver : HLD조아 (정희승, 임성재, 최승민) - 192분&lt;br /&gt;Open First Solver : cki86201 - 29분&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;각 정점에 색이 칠해져 있는 트리가 주어진다.&lt;br /&gt;조상-자식 관계이면서 색이 같은 두 정점이 존재하지 않도록 트리의 루트를 잡을 때, 루트로 가능한 정점을 모두 구하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그냥 갑자기 이런 문제가 떠올라서, 풀리는지 제대로 확인도 안 하고 대회 문제 Shortlist에 던져놓았다. 나는 ‘열심히 코딩하면 $O(N lgN)$ 즈음에 풀리겠지’까지만 생각했는데, 세빈이와 imeimi2000가 뭔가 뚝딱뚝딱 하더니 갓 풀이를 만들어 놓아서 정말정말 신기했다.&lt;/p&gt;

&lt;p&gt;데이터를 만들기 아주 어려운 문제라고 생각한다. $O(N^2)$ 시간 커팅 야매라던가, 코딩 미스라던가, 랜덤을 섞다던가…. 통과시키면 안되는 풀이가 아주 많고, 트리와 색을 구성하는 것이 아주 까다로움에도 불구하고, 데이터는 아주 완벽하다고 생각한다. 열심히 준비하느라 고생한 세빈이에게 아낌없이 박수를 쳐주자.&lt;/p&gt;

&lt;h4 id=&quot;풀이-1&quot;&gt;풀이 1&lt;/h4&gt;

&lt;p&gt;이 문제는 교내에서 두 팀, Open에서 네 명이 풀었고, 전부 본 풀이와 비슷한 방법으로 해결하였다.&lt;/p&gt;

&lt;p&gt;트리 중 간선 ${ u, v }$을 생각하자. 이 간선을 끊는다면, 트리는 두 개의 트리 $T_u$와 $T_v$로 분리된다. 여기서, $T_u$는 정점 $u$가 포함된 트리, $T_v$는 정점 $v$가 포함된 트리다.&lt;/p&gt;

&lt;p&gt;만일, $u$와 색이 같은 $T_v$ 상의 정점이 존재한다면, $T_u$의 모든 정점은 답의 후보에서 제외된다. 이렇게 모든 $N-1$개의 간선에 대하여, 답의 후보를 제거하자. 남은 후보 정점은 모두 루트가 될 수 있음을 보일 수 있다.&lt;/p&gt;

&lt;p&gt;따라서, 우리가 구현해야 하는 부분은 크게 두 가지로 볼 수 있다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$T_v$의 정점 중 $u$와 색이 같은 정점이 존재하는지 판별 : DFS Ordering과 같은 색을 가진 정점의 index를 모아두는 $O(N)$ 전처리로, 각 쿼리마다 이분탐색 등으로 $O(\lg N)$에 판별할 수 있다.&lt;/li&gt;
  &lt;li&gt;답의 최종 후보 정점 결정 : 각 간선에 대하여, $O(1)$에 답이 될 수 없는 부트리의 루트에만 정보를 저장한 후, $O(N)$의 DFS를 통하여, 최종 후보를 알아낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간복잡도는 $O(N \lg N)$, 공간 복잡도는 $O(N)$다. 구현 방식에 따라 코딩량이 크게 다른 듯 하다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-2&quot;&gt;풀이 2&lt;/h4&gt;

&lt;p&gt;이 풀이는 내가 생각한 방법이다. 아무 생각 없이 손만 열심히 움직이는 풀이다.&lt;/p&gt;

&lt;p&gt;색이 $C$로 같은 정점을 모두 모아, 트리 압축을 해보자. 이제 두 가지 경우가 있다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;색이 $C$인 정점 중 Leaf가 아닌 정점이 존재하는 경우 : 모든 정점이 답이 될 수 없다.&lt;/li&gt;
  &lt;li&gt;색이 $C$인 정점이 모두 Leaf인 경우 : 압축된 트리 중 색이 $C$가 아닌 모든 정점이 답의 후보가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모든 색에 대하여, 위의 과정을 진행한 후, 모든 답의 후보의 교집합을 구하면 그것이 답이 된다.&lt;/p&gt;

&lt;p&gt;트리 압축 테크닉을 언급하고 싶어서, 본 풀이를 적었다. 시간복잡도와 공간 복잡도 모두 $O(N \lg N)$다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-3&quot;&gt;풀이 3&lt;/h4&gt;

&lt;p&gt;세빈이의 풀이 슬라이드를 보면, “DFS를 돌면서 각 색깔별로 따로 스택을 관리하여 선형에 풀 수 있다.”고 적혀 있는데, 나는 이 의미를 모르겠다. 선형 풀이도 $O(N \lg N)$ 풀이처럼 다양한 듯 하나, 여기서 나는 imeimi2000의 갓 풀이만 설명할 것이다.&lt;/p&gt;

&lt;p&gt;다음을 차례대로 관찰하자:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;유일한 색을 가지는 정점의 집합을 $S$라 하자. 답은 $S$의 부분집합이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;풀이 2&lt;/strong&gt;에 의해, 답이 되는 정점은 여러 부트리의 교집합의 형태를 가진다. 고로, 답이 되는 정점은 모두 이어져있다.&lt;/li&gt;
  &lt;li&gt;인접한 두 정점 $u, v \in S$을 생각하자. $u$가 루트가 될 수 있다면, $v$ 또한 루트가 될 수 있다.&lt;/li&gt;
  &lt;li&gt;따라서 루트가 될 수 있는 정점을 하나만 찾을 수 있다면, BFS 따위를 통하여 다른 모든 답을 $O(N)$에 구할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 우리는 루트가 될 수 있는 정점 하나를 찾는 데에 집중할 것이다. 조금 더 정확하게, $1$번 정점과 가장 가까우면서 루트가 될 수 있는 정점 $r$을 찾을 것이다. (답이 공집합이 아니라고 가정하고 있음에 유의하라.)&lt;/p&gt;

&lt;p&gt;$1$번 정점을 루트로 했을 때, 정점 $v$의 부트리에 $v$와 색이 같은 정점이 있다면, 우리는 $v$를 “충돌 정점”이라 부르자. 만약에 그 어떤 충돌 정점도 존재하지 않는다면, $r = 1$다. 이제 충돌 정점이 있는 경우에 대하여 다음을 관찰하자:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모든 충돌 정점은 $1$번 정점과 정점 $r$을 잇는 경로 위에 존재한다. 만일 그렇지 않다면, 이는 $r$이 답이 될 수 없음을 유도한다.&lt;/li&gt;
  &lt;li&gt;$1$번 정점과 가장 먼 충돌 정점을 $x$라 하자. $r$은 $x$의 부트리에 존재한다.&lt;/li&gt;
  &lt;li&gt;$r$의 부모 정점은 $x$다. $r$의 부모 정점이 $p \ne x$라면, 다음과 같은 모순이 일어난다:
    &lt;ol&gt;
      &lt;li&gt;$p \in S$라면, $r, p \in S$가 서로 인접해 있고 $r$은 답이 될 수 있으므로, $p$ 또한 답이 될 수 있다. 따라서 정의에 의해 $r = p$여야 한다.&lt;/li&gt;
      &lt;li&gt;$p \notin S$라면, $p$와 색이 같은 정점 $v \ne p$가 존재한다. $r$이 답이 될 수 있으므로, $v$는 $p$의 부트리 안에 있어야만 한다. 이 경우, $p$는 충돌 정점이 되므로, 정의에 의해 $x = p$여야 한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;$x$의 부트리에 $x$와 색이 같은 정점은 $r$의 부트리에 존재한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 위의 모든 내용을 종합하여, 아래의 알고리즘을 시행하자:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;한 번의 DFS로 $O(N)$에 정점 $x$를 구한다.&lt;/li&gt;
  &lt;li&gt;과정 1.에서 충돌 정점이 없었다면, $r = 1$다.&lt;/li&gt;
  &lt;li&gt;과정 1.에서 충돌 정점이 있었다면, 다음 조건을 만족하는 정점 $y$를 찾아, $r := y$로 설정한다.
    &lt;ol&gt;
      &lt;li&gt;$y$는 $x$의 자식.&lt;/li&gt;
      &lt;li&gt;$y$의 부트리 중 $x$와 색이 같은 정점이 존재.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;$r$이 답이 될 수 있는지 한 번의 DFS로 $O(N)$에 판별한다.&lt;/li&gt;
  &lt;li&gt;$r$이 답이 될 수 있다면, BFS 등으로 모든 답을 $O(N)$에 구한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;우리가 논리를 전개하기에 앞서, 우리는 “답이 공집합이 아님”을 가정하였다. 그러나, 답이 공집합이더라도 위의 알고리즘은 과정 4.에 의해 올바른 답을 알려준다. 따라서, 위의 알고리즘은 정당하다.&lt;/p&gt;

&lt;p&gt;시간복잡도와 공간 복잡도 모두 $O(N)$다.&lt;/p&gt;

&lt;h3 id=&quot;촛불과-그림자&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18190&quot;&gt;촛불과 그림자&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;개요-5&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 윤교준 / 데이터 제작자 : 윤교준&lt;br /&gt;운영진의 최단 코드 : 2615 bytes (C++)&lt;br /&gt;교내 First Solver : N/A&lt;br /&gt;Open First Solver : N/A&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;볼록 다각형 내부에 볼록 다각형이 포함되어 있다.&lt;br /&gt;쿼리로 촛불의 위치가 주어질 때, 안쪽 다각형에 의하여 만들어지는 그림자 영역의 넓이를 구하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;출제진이 두 명인데, 한 명(본인)은 기하가 세상의 전부라고 생각하고, 또다른 한 명(김세빈)은 기하를 혐오하나 풀라고 하면 군말없이 푸는 사람이다. 그렇다면, 기하 문제가 나온다는 것은 예상 범위 안이라고 생각한다.&lt;/p&gt;

&lt;p&gt;교내 대회에서 라이브러리를 미리 준비해서 사용할 수 있게 한 가장 큰 이유가 이 문제의 존재다. ‘기하 라이브러리로 한 번 풀어볼테면 풀어봐라’ 느낌으로 출제했는데, 아무도 기하 라이브러리를 준비하지 않은 점이 조금 아쉽다. 사실 이런 류의 문제가 좋지 않음은 인지하고 있었으나, Open All Solve 방지용으로 출제한 점도 없지 않아 있다.&lt;/p&gt;

&lt;p&gt;Open 대회 1위와 2위 수상자는 다른 11개의 문제를 모두 풀고 시간이 남아, 본 문제에도 소스코드를 제출하였으나 아쉽게도 맞지 못하였다. 그들이 제출한 소스 코드를 공개하자면:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Ainta&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trolling&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;so&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hard&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;taeyeon_ss의 C++14 코드 (채점 번호 : 16464908)&lt;/center&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&amp;lt;iostream&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ainta trolling so hard&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;taeyeon_ss의 C++14 코드 (채점 번호 : 16464935)&lt;/center&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E번 보고 저녁 먹으러 갑니다 ^^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;tlwpdus의 Text 코드 (채점 번호 : 16464795)&lt;/center&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;tlwpdus의 C++14 코드 (채점 번호 : 16465014)&lt;/center&gt;

&lt;p&gt;네 번의 제출이 있었으나, 한 번의 컴파일 오류를 제외하고 모두 ‘틀렸습니다’ 판정을 받았다. 살짝만 고치면 정해가 됨에도 불구하고, 그들이 왜 소스코드를 고치지 않았는지 나는 모르겠다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-4&quot;&gt;풀이&lt;/h4&gt;

&lt;p&gt;촛불의 위치가 쿼리로 주어지지만 않았더라도 이 사단이 나지는 않았을 것이다. 우리는 하나의 쿼리를 $O(\lg N + \lg M)$에 풀기 위하여 다음을 모두 구현하여야 한다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;점과 볼록 다각형 간의 위치 관계 판별 (내부, 외부, 경계 위 판별)
    &lt;ul&gt;
      &lt;li&gt;볼록 다각형을 윗쪽 껍질과 아랫쪽 껍질로 분해한다면, 이분 탐색을 이용하여 $O(\lg V)$에 판별할 수 있다. 여기서 $V$는 꼭짓점의 개수다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;볼록 다각형 외부의 점에서 다각형에 그은 접선 구하기
    &lt;ul&gt;
      &lt;li&gt;설명의 편의를 위하여, 외부의 점을 $A$, 다각형의 꼭짓점을 $P_1, P_2, \cdots, P_V$라 하자.&lt;/li&gt;
      &lt;li&gt;아까와 비슷하게, 다각형을 윗쪽과 아랫쪽으로 분해하자. 점 $A$와 각 껍질의 꼭짓점을 잇는 직선의 기울기는 삼분 탐색이 가능한 형태다. 고로, 각 껍질에 대하여 삼분 탐색을 이용하여 접선을 구한다.&lt;/li&gt;
      &lt;li&gt;또다른 방법으로, 세빈이가 사용한 방법을 소개한다. 직선 $\overleftrightarrow{A P_1}$과 다각형의 교점을 생각하자. $P_1$가 아닌 교점이 선분 $\overline{P_k P_{k+1}}$ 위에 존재한다면, 두 접점은 각각 $P_1, \cdots, P_k$ 중에 하나, $P_{k+1},  \cdots, P_V$ 중에 하나다. 접점은 각 범위 내에서 이분 탐색으로 찾을 수 있다.&lt;/li&gt;
      &lt;li&gt;두 방법 모두 시간복잡도는 $O(\lg V)$다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;볼록 다각형과 반직선의 교점 구하기
    &lt;ul&gt;
      &lt;li&gt;반직선을 $\overrightarrow{AB}$라 하자. 또한, 점 $A$와 $B$는 모두 다각형 내부에 존재한다고 하자. 반직선과 다각형의 교점이 선분 $\overline{P_k P_{k+1}}$ 위에 존재한다면, 두 반직선 $\overrightarrow{A P_1}$와 $\overrightarrow{A P_k}$가 만드는 영역에 점 $B$가 존재하지 않는 반면에, $\overrightarrow{A P_1}$와 $\overrightarrow{A P_{k+1}}$가 만드는 영역에는 점 $B$가 포함된다.&lt;/li&gt;
      &lt;li&gt;$k$의 값은 이분 탐색을 이용하여 $O(\lg V)$에 찾을 수 있다. 이후, 교점의 좌표는 두 직선의 식을 연립하여 구할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부채 형태의 다각형의 넓이 구하기
    &lt;ul&gt;
      &lt;li&gt;다각형 $O P_s P_{s+1} \cdots P_e$의 넓이는 $\overrightarrow{O P_i} \times \overrightarrow{O P_ {i+1}}$의 Prefix Sum을 $O(V)$에 전처리해둠으로써 $O(1)$에 계산할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 소과정을 모두 구현하였다면, 이들을 조합하여 각 쿼리에 대해 $O(\lg N + \lg M)$에 답할 수 있다. 시간복잡도는 $O(N + M + Q(\lg N + \lg M))$, 공간 복잡도는 $O(N + M)$다.&lt;/p&gt;

&lt;h4 id=&quot;첨언&quot;&gt;첨언&lt;/h4&gt;

&lt;p&gt;내가 문제를 만들고 데이터를 만들었기 때문에, 자업자득으로 나 또한 출제 고통을 엄청 받았다. 올바른 정해 코드를 작성하기까지 수차례 소스코드를 갈아엎었고, Naive 코드와 Checker 코드 또한 작성하기 까다롭기에 힘들었다. 두 거대한 볼록 다각형이 서로 포함 관계에 있어야 하기에, 데이터를 만들기 위하여 다른 문제에 비해 꽤 많은 시간을 들였다.&lt;/p&gt;

&lt;p&gt;시간 제한이 1초로 빡빡한 이유는, 좌표 범위의 제약으로 인하여 $N$과 $M$이 $10^5$이 될 수 없기 때문이다. 실수 오차가 $10^{-6}$ 이하인지 엄밀하게 검증하지 않아서, 좌표 범위를 대충 작게 주었는데, $N = 10^5$인 데이터를 만들 수 없다는 점이 조금 아쉽다. 그렇다고 다시 작업해서 이를 고치고 싶지는 않다.&lt;/p&gt;

&lt;h3 id=&quot;피아노-연주&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18191&quot;&gt;피아노 연주&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;개요-6&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 김세빈 / 데이터 제작자 : 윤교준&lt;br /&gt;운영진 최단 코드 : 711 bytes (C++), 374 bytes (Python)&lt;br /&gt;교내 First Solver : 뚝심햄구이 (이종영, 안지민, 최은수) - 214분&lt;br /&gt;Open First Solver : tlwpdus - 22분&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$M$개의 음으로 이루어진 곡을 피아노로 연주하려고 한다.&lt;br /&gt;각각의 음을 어떤 손가락으로 연주할지 결정하여 곡의 난이도의 최솟값을 구하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 문제는 교내 대회에서 세빈이가 가장 아쉬워한 문제다. 정말로 적게 잡아도 전체의 1/4 이상은 풀 것이라고 예상하였는데, 실제로는 모든 팀이 이 문제를 풀려는 시도를 하지 않아, 결과적으로 1위 팀이 대회가 끝나갈 무렵에 푼 것이 전부였다. 1위 팀이 어려운 문제를 먼저 빠르게 풀어버려서 다른 팀에게 난이도에 대한 혼란을 주고, B번 문제였던 “라면 사기”가 아주 어려웠기 때문에, 대부분이 이 문제를 잡을 시간이 없었을 것이라고 추측해본다.&lt;/p&gt;

&lt;p&gt;교내 대회에서는 한 팀밖에 풀지 못했던 반면에, Open에서는 6명이 쉬운 냄새를 잘 맡고 찾아와 풀어주셨다. Open에서라도 잘 풀려서 다행이라고, 세빈이는 대회를 되돌아보며 말하곤 한다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-5&quot;&gt;풀이&lt;/h4&gt;

&lt;p&gt;곡의 난이도를 결정하는 식 $\left| \left( P_{i+1} - P_i \right) - \left( X_{F_{i+1}} - X_{F_i} \right) \right|$의 의미를 파악한다면, 문제를 더 쉽게 이해할 수 있다. 이는 “인접한 두 음을 연주할 때, 손이 움직이는 거리”로 생각하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;이제, 이분 탐색을 적용하여, 최솟값 문제를 결정 문제로 환원하자. 즉, 손이 한 번에 최대로 $L$만큼만 움직일 수 있을 때, 곡을 완주하는 것이 가능한 지 판별하면, 전체 문제를 푸는 데 충분하다.&lt;/p&gt;

&lt;p&gt;각 음을 연주할 수 있는 손가락의 번호는 항상 구간을 이룬다는 것을 관찰하여야 한다. 예를 들어, 첫 번째 음부터 $i$번째 음까지 차례대로 연주하여, $i$번째 음을 $S_i$ 이상 $E_i$ 이하 번째의 손가락으로 연주할 수 있다고 하자. 그렇다면, $(i+1)$번째 음은 $S_{i+1}$ 이상 $E_{i+1}$ 이하 번째의 손가락으로 연주할 수 있으며, 이 값은 $S_i$와 $E_i$로부터 계산할 수 있다. 이것이 성립하는 이유는 인접한 손가락의 거리가 $K$로 일정하기 때문이다.&lt;/p&gt;

&lt;p&gt;고로, $S_1 = 1$, $E_1 = N$으로 두고, $S_i$와 $E_i$ 값을 차례대로 구하면, 결정 문제를 풀 수 있다. 하나의 결정 문제는 $O(M)$에 풀 수 있으므로, 전체 문제를 $O(M \lg X)$에 해결할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;여담&quot;&gt;여담&lt;/h4&gt;

&lt;p&gt;본 문제의 초기 버전에서는 $X_i$ 값이 모두 입력으로 주어졌다. 이 경우에는 각 음을 연주할 수 있는 손가락의 집합이 구간을 이루지 못하기 때문에, $X_i = (i-1)K$로 수정하였다.&lt;/p&gt;

&lt;p&gt;독자는 초기 버전의 문제를 $O(M \sqrt{N} \lg X)$나, 혹은 이보다 빠르게 풀 수 있겠는가?&lt;/p&gt;

&lt;h3 id=&quot;보고-정렬&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18192&quot;&gt;보고 정렬&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;개요-7&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 김세빈 / 데이터 제작자 : 김세빈&lt;br /&gt;운영진 최단 코드 : 239 bytes (C++)&lt;br /&gt;교내 First Solver : 🇰🇷815🇰🇷 (고동현, 이민제, 이강민) - 19분&lt;br /&gt;Open First Solver : kcm1700 - 29분&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;수열에서 어떤 구간을 잡아 랜덤 셔플하는 작업만을 이용하여, 주어진 순열을 효율적으로 정렬하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;길이 $200$의 순열을 $2500$번 이하의 랜덤 셔플을 이용하여 정렬하는, 참신한 문제다.&lt;/p&gt;

&lt;p&gt;백준님께서 나는코더다 대회에 Interactive 문제를 낸다면 이 유형을 구현해주겠다고 약속해주셔서, 나와 세빈이가 출제한 두 개의 Interactive 문제 중 하나다. 랜덤 셔플을 정말로 ‘랜덤’하게 구현해야 하기 때문에, Interactive 유형이 아니라면 출제될 수 없는 문제라고 생각한다. 나는코더다 2019 송년대회를 기점으로 하여, 앞으로 Interactive 유형의 질 좋은 문제가 많이 나오기를 기대한다.&lt;/p&gt;

&lt;p&gt;나는 이 문제가 교내 팀에게 꽤 당혹스럽게 느껴질 것이라 예상하였으나, 전체 18팀 중 14팀이나 풀어버렸다. 특히, “🇰🇷815🇰🇷” 팀이 읽자마자 풀어서 제출한 장면이 매우 인상 깊다.&lt;/p&gt;

&lt;p&gt;세상에는 다양한 정렬 알고리즘이 있으나, 어떤 알고리즘을 채택하여 어떻게 구현하느냐에 따라서 필요한 랜덤 셔플의 횟수가 다르다는 점이 이 문제의 매력같다. 정답률 또한 교내 37.5%, Open 58%로, 이 문제가 그렇게 쉽지만은 않다는 것을 잘 보여준다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-6&quot;&gt;풀이&lt;/h4&gt;

&lt;p&gt;다양한 풀이가 있을 것이라고 생각한다. 운영진은 크게 두 가지 풀이(삽입 정렬과 퀵 정렬)를 가지고 있으며, 대부분의 참가자도 이 두 가지 중 하나로 풀었다. 여기서는 제일 설명이 깔끔한, 삽입 정렬 풀이를 소개한다.&lt;/p&gt;

&lt;p&gt;다음 알고리즘은 대략 $O(N \lg N)$번의 랜덤 셔플로 순열을 정렬한다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;아직 정렬되지 않은 최초의 위치를 찾는다. 즉, $A_s \ne s$인 최소 $s$를 찾는다.&lt;/li&gt;
  &lt;li&gt;만약 그러한 $s$가 존재하지 않는다면, 순열 $A$는 정렬되었으므로 종료한다.&lt;/li&gt;
  &lt;li&gt;만일 그러한 $s$가 존재한다면, $A_e = s$인 $e$를 찾은 후, $[s, e]$를 랜덤 셔플한다.&lt;/li&gt;
  &lt;li&gt;다시 과정 1.로 돌아간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 알고리즘을 간략하게 설명하자면, $s$가 제자리를 찾을 때까지, 구간 $[s, (s \text{가 존재하는 위치})]$를 랜덤 셔플하는 것을 반복하는 것이다.&lt;/p&gt;

&lt;p&gt;이제, $s$가 제자리를 찾기 위하여, 평균적으로 몇 번의 랜덤 셔플이 필요한지 계산해보자. 특정한 수 하나를 $n$칸 왼쪽으로 옮기는 데 필요한 횟수의 기댓값을 $D_n$라고 정의하자. 정의에 의하여 다음 귀납식을 세울 수 있다:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;D_n = 1 + \frac{0 + D_1 + D_2 + \cdots + D_n}{n+1}&lt;/script&gt;

&lt;p&gt;세빈이의 풀이 슬라이드에 적힌 풀이법을 이용하면 다음을 알 수 있다:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;D_n = 1 + \sum_{k = 1}^{n} \frac{1}{k} \approx 2 + \ln n&lt;/script&gt;

&lt;p&gt;따라서, 총 랜덤 셔플 횟수의 기댓값은 $O(N \lg N)$다. 실제로 검수 과정에서 셔플 횟수가 $1200$번을 넘은 경우가 단 한 번도 발생하지 않았다.&lt;/p&gt;

&lt;h3 id=&quot;비행기-타고-가요&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18193&quot;&gt;비행기 타고 가요&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;개요-8&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;출제자 : 윤교준 / 데이터 제작자 : TAMREF&lt;br /&gt;운영진 최단 코드 : 1143 bytes (C++)&lt;br /&gt;교내 First Solver : 뚝심햄구이 (이종영, 안지민, 최은수) - 23분&lt;br /&gt;Open First Solver : ainta - 78분&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$N$개의 도시가 있다.&lt;br /&gt;비용 $A_i$로 $[B_i, C_i]$의 도시에서 $[D_i, E_i]$의 도시로 이동할 수 있다.&lt;br /&gt;$K$번 도시에서 출발하여, 각 도시로 이동하기 위하여 필요한 최소 비용을 구하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Trivial한 자료구조 문제를 생각하다가, 적당한 양산형 문제를 하나 만들었고, 그것이 이 문제다.&lt;/p&gt;

&lt;p&gt;교내 팀 중 “뚝심햄구이”가 23분만에 푼 것이 놀라운데, 대회가 끝나고 들어보니 팀원 중 한 명이 만든 문제와 유사했다고 한다. 기존에 공개된 문제와 대회 문제간의 유사도를 비교하는 작업을 열심히 했음에도 불구하고, 이를 걸러내지 못한 점이 아쉽다. 다만, 풀이를 정확하게 안다고 해도 23분이라는 짧은 시간 안에 정확하게 코딩했다는 점은 칭찬을 해주고 싶다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-1-1&quot;&gt;풀이 1&lt;/h4&gt;

&lt;p&gt;문제 설명을 그래프로 환원하자. 즉, $[B_i, C_i]$의 정점에서 $[D_i, E_i]$의 정점을 향하는 가중치 $A_i$의 간선이 아주 많이 있는 그래프에서, 정점 $K$를 시작점으로 하여 Dijkstra 알고리즘을 시행하는 문제라고 생각할 수 있다.&lt;/p&gt;

&lt;p&gt;여기서 우리는 가장 큰, 그러나 유일한 문제점에 부딪힌다: “그래프의 간선이 너무 많다.”&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위하여, Segment Tree의 아이디어를 적용하자. 두 구간 $[B_i, C_i]$과 $[D_i, E_i]$는 Segment Tree의 $O(\lg N)$개의 노드들로 표현할 수 있다. 다시 말하면, 아랫방향으로 가중치 $0$으로 연결된 Segment Tree와, 윗방향으로 가중치 $0$으로 연결된 Segment Tree를 이용하여, 간선 $[B_i, C_i] \times [D_i, E_i]$를 $O(\lg N)$개의 추가 간선만으로 모두 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;결과적으로 우리는 간선의 개수를 $O(N + M \lg N)$개로 줄였다. 시간복잡도는 $O(N \lg N + M \lg ^2 N)$ 혹은 $O(N \lg N + M \lg N)$다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-2-1&quot;&gt;풀이 2&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;풀이 1&lt;/strong&gt;에서 세빈이가 제안한 개선안이다. 위에서 Segment Tree를 이용하여 구간을 $O(\lg N)$개의 노드로 대체했던 것을, Sparse Table의 아이디어로 구간을 $2$개의 노드로 대체할 수 있다.&lt;/p&gt;

&lt;p&gt;이 경우, 간선은 총 $O(N \lg N + M)$개로, 시간복잡도는 $O(N \lg ^2 N + M \lg N)$ 혹은 $O(N \lg N + M \lg N)$다.&lt;/p&gt;

&lt;h4 id=&quot;풀이-3-1&quot;&gt;풀이 3&lt;/h4&gt;

&lt;p&gt;이제 그래프를 명시적으로 그리지 않고, Dijkstra 알고리즘을 적용하는 방법을 생각해보자.&lt;/p&gt;

&lt;p&gt;$[B_i, C_i]$의 정점 중 $K$번 정점과 가장 가까운 정점을 $V_i$라 하자. 간선 $[B_i, C_i] \times [D_i, E_i]$가 의미있는 경우는 오직 $V_i$에서 $[D_i, E_i]$로 거리 정보를 뿌려줄 때뿐이다.&lt;/p&gt;

&lt;p&gt;이러한 아이디어를 활용하여 다음 알고리즘을 작성할 수 있다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;”$[s, e]$의 정점의 최단 경로 길이는 $w$ 이하다”는 정보를 $(w, s, e)$라고 표현하자. 또한 아직까지 방문하지 않은 정점의 집합을 $V$라 하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Priority Queue $\zeta$에 $(0, K, K)$을 넣는다. 또한 $V := \{ 1, 2, \cdots, N \}$라 하자.&lt;/li&gt;
  &lt;li&gt;$\zeta = \emptyset$라면, 알고리즘을 종료한다.&lt;/li&gt;
  &lt;li&gt;$\zeta$에서 $w$가 가장 작은 $(w, s, e)$를 pop한다.&lt;/li&gt;
  &lt;li&gt;$V \cap [s, e] = \emptyset$일 때까지 다음을 반복한다:
    &lt;ol&gt;
      &lt;li&gt;$[s, e]$ 중 아직 방문하지 않은 정점 $v$를 잡자. 즉, $v \in V \cap [s, e]$인 $v$를 아무거나 하나 잡자.&lt;/li&gt;
      &lt;li&gt;$K$번 정점에서 $v$로 가는 최단 경로의 길이는 $w$라고 저장한다.&lt;/li&gt;
      &lt;li&gt;$V := V \setminus \{ v \}$&lt;/li&gt;
      &lt;li&gt;$v$를 포함하는 모든 구간 $[B_i, C_i]$에 대하여, $\zeta$에 $(w + A_i,  D_i, E_i)$를 넣은 후, 구간을 삭제한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;과정 2.로 돌아간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;구간을 찾고, 지우는 과정은 Segment Tree를, 구간 내에서 아직 방문하지 않은 정점을 찾는 것은 Disjoint Set을 이용하여 구현할 수 있다. 시간복잡도는 $O(N \lg N + M \lg N)$다.&lt;/p&gt;</content><author><name>Gyojun Youn</name></author><category term="대회" /><category term="풀이" /><category term="출제" /><category term="나는코더다" /><summary type="html">머릿말</summary></entry></feed>